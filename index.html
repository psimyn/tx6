<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TX-6 Bluetooth Control</title>
    <meta property="og:title" content="TX-6 Remote">
    <meta property="og:description" content="Control TX-6 with Bluetooth or USB">
    <meta property="og:image" content="https://tx6.psimyn.com/tx6-og-1200.jpg">
    <link rel="stylesheet" href="style.css">
    <meta name="theme-color" content="#e2e2e4">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script defer src="alpine-3.14.9.min.js"></script>
</head>

<body x-data="tx6Controller()" x-init="init()">
    <div class="knob-container">
        <header>
            <div class="status" x-show="status" x-text="status"></div>
            <div class="connection-buttons">
                <template x-for="type in ['ble', 'usb']">
                    <button @click="connect(type)" class="connect-btn" x-show="!isConnected" :disabled="connecting"
                        x-text="`Connect ${type === 'ble' ? 'Bluetooth' : 'USB'}`">
                    </button>
                </template>
            </div>
            <div class="track-selector">
                <template x-for="i in 6" :key="i">
                    <button class="track-button" :class="{ active: currentTrack === i-1 }" @click="selectTrack(i-1)"
                        x-text="`T${i}`">
                    </button>
                </template>
            </div>
        </header>

        <div class="knob-wrapper">
            <select x-model="currentSliderMode" @change="selectSliderMode($event.target.value)" class="mode-select">
                <option value="7">VOL</option>
                <option value="92">AUX</option>
                <option value="91">FX1</option>
                <option value="93">CMP</option>
            </select>
            <div class="volume-slider">
                <input type="range" min="0" max="127" :value="sliderValue" @input="handleSliderChange($event)">
                <input type="range" min="0" max="127" x-model="sliderOutputValue" class="slider-overlay" readonly
                    tabindex="-1">
            </div>
            <div class="value-display">
                <span class="knob-value value-large" x-text="Math.floor(sliderValue * 100 / 127)"></span>
            </div>
        </div>

        <div class="control-buttons">
            <div class="knob-wrapper">
                <select x-model="currentEqMode" @change="selectEqMode($event.target.value)" class="mode-select">
                    <option value="74">FLT</option>
                    <option value="85">HIGH</option>
                    <option value="86">MID</option>
                    <option value="87">LOW</option>
                </select>
                <div x-data="knob(knobConfigs.eq)" class="knob" @mousedown="startDrag($event)"
                    @touchstart="startDrag($event)" x-init="knobData.value = knobs.eq.value" x-effect="knobData.value = knobs.eq.value">
                    <div class="knob-indicator indicator-small"
                        :style="`background: ${eqIndicatorColor}; transform: translateX(-50%) rotate(${midiToAngle(knobData.value)}deg)`">
                    </div>
                </div>
                <div class="value-display">
                    <span class="knob-value" x-text="eqDisplayValue"></span>
                </div>
            </div>
            <button @click="toggleView('synth')" class="fx-settings-button"
                :class="{ active: settingsView === 'synth' }">SYNTH</button>
        </div>

        <div class="fx-buttons">
            <button @click="toggleView('fx')" class="fx-settings-button white"
                :class="{ active: settingsView === 'fx' }">FX</button>
            <template x-for="i in 2">
                <button @click="toggleFx(i)" class="fx-button"
                    :class="{ active: fx[`fx${i}Active`], orange: i === 2 }"><span class="fx-button-inner"
                        x-text="`FX${i}`"></span></button>
            </template>
        </div>

        <!-- FX Settings Overlay -->
        <div class="fx-settings-overlay" :class="{ active: settingsView === 'fx' }">
            <div class="fx-channel-tabs">
                <template x-for="ch in [7, 8]">
                    <div class="fx-channel-tab" :class="{ active: fx.currentChannel === ch }"
                        @click="fx.currentChannel = ch; updateFxDisplay()" x-text="`FX ${ch === 7 ? 'I' : 'II'}`">
                    </div>
                </template>
            </div>

            <div class="fx-settings-knobs">
                <select x-model="fx.channels[fx.currentChannel].engine" @change="handleFxEngineChange"
                    class="fx-engine-select">
                    <template x-for="(option, index) in fx.channels[fx.currentChannel].types" :key="index">
                        <option :value="calculateMidiValue(index, fx.channels[fx.currentChannel].types.length)"
                            x-text="option"></option>
                    </template>
                </select>

                <template x-for="knobId in ['fxReturn', 'fxParam1', 'fxParam2']">
                    <div class="knob-wrapper" x-show="knobId !== 'fxParam2' || fxParam2Visibility">
                        <div x-data="knob(knobConfigs[knobId])" class="knob" @mousedown="startDrag($event)"
                            @touchstart="startDrag($event)" x-init="knobData.value = knobs[knobId].value"
                            x-effect="knobData.value = knobs[knobId].value">
                            <div class="knob-indicator indicator-small"
                                :style="`transform: translateX(-50%) rotate(${midiToAngle(knobData.value)}deg)`">
                            </div>
                        </div>
                        <div class="value-display">
                            <span class="knob-value" x-text="getKnobDisplayValue(knobId)"></span>
                            <span class="knob-label" x-text="getKnobLabel(knobId)"></span>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- LFO Overlay -->
        <div class="fx-settings-overlay lfo-overlay" :class="{ active: settingsView === 'lfo' }" style="z-index: 20;">
            <div style="position:relative;display:flex;flex-direction:column;align-items:flex-start;gap:1rem;">
                <div class="knob-wrapper">
                    <div class="flex gap-1">
                        <select x-model="currentLfoIndex" @change="updateLfoKnobs()" class="fx-engine-select"
                            style="min-width:80px;">
                            <template x-for="i in 10">
                                <option :value="i-1" x-text="`LFO ${i}`"></option>
                            </template>
                        </select>
                        <select x-model="globalLfos[currentLfoIndex].target" class="fx-engine-select">
                            <option value="vol">VOL</option>
                            <option value="fx1">FX1</option>
                            <option value="cmp">CMP</option>
                            <option value="flt">FLT</option>
                        </select>
                        <select x-model="globalLfos[currentLfoIndex].assignedTrack" class="fx-engine-select">
                            <template x-for="i in 6">
                                <option :value="i-1" x-text="`T${i}`"></option>
                            </template>
                        </select>
                    </div>
                </div>

                <div style="display:flex;align-items:center;gap:1rem;position:relative;">
                    <select x-model="globalLfos[currentLfoIndex].shape" class="fx-engine-select lfo-shape"
                        @change="$nextTick(() => drawLfoWaveform())" style="writing-mode:horizontal-tb;">
                        <template x-for="shape in ['sine', 'triangle', 'square', 'saw', 'revsaw', 'noise']">
                            <option :value="shape" x-text="shape.charAt(0).toUpperCase() + shape.slice(1)"></option>
                        </template>
                    </select>
                    <canvas id="lfo-canvas" width="300" height="100"
                        style="border: 1px solid var(--knob-border); border-radius: 4px;"></canvas>
                </div>

                <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:1rem;justify-items:center;">
                    <template x-for="lfoKnob in ['lfoRate', 'lfoAmount', 'lfoPhase']">
                        <div class="knob-wrapper">
                            <label class="knob-label" x-text="lfoKnob.replace('lfo', '').toUpperCase()"></label>
                            <div x-data="knob(knobConfigs[lfoKnob])" class="knob" @mousedown="startDrag($event)"
                                @touchstart="startDrag($event)"
                                x-init="knobData.value = globalLfos[currentLfoIndex][lfoKnob.replace('lfo', '').toLowerCase()]"
                                x-effect="knobData.value = globalLfos[currentLfoIndex][lfoKnob.replace('lfo', '').toLowerCase()]">
                                <div class="knob-indicator indicator-small"
                                    :style="`transform: translateX(-50%) rotate(${getKnobAngle(lfoKnob, knobData.value)}deg)`">
                                </div>
                            </div>
                            <div class="value-display">
                                <span class="knob-value" x-text="getLfoKnobDisplay(lfoKnob)"></span>
                                <span class="knob-label" x-text="getLfoKnobUnit(lfoKnob)"></span>
                            </div>
                            <div class="rate-buttons" x-show="lfoKnob === 'lfoRate'">
                                <template x-for="mult in [0.25, 0.5, 1/3, 1, 2, 4]">
                                    <button @click="setLfoRateFromBpm(mult)" class="rate-button"
                                        :class="{ 'active': isRateButtonActive(mult) }"
                                        x-text="getRateButtonLabel(mult)">
                                    </button>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>

                <button @click="settingsView = null" class="overlay-close-btn">BACK</button>
            </div>
        </div>

        <!-- Synth Overlay -->
        <div class="fx-settings-overlay synth-overlay" :class="{ active: settingsView === 'synth' }"
            style="z-index: 20;">
            <div style="position:relative;display:flex;flex-direction:column;align-items:flex-start;gap:1rem;">
                <div class="synth-controls">
                    <div class="synth-input-wrapper" style="display: flex; align-items: center; gap: 1rem;">
                        <div>
                            <label class="knob-label">SEQ</label>
                            <input type="number" min="0" max="29" x-model="synthSettings.seq" @input="handleSeqChange()"
                                class="seq-input" placeholder="0-29">
                        </div>
                        <div class="seq-preview-grid" x-show="synthSettings.seq !== null && synthSettings.seq !== ''">
                            <template x-for="row in 2">
                                <div class="seq-preview-row" style="display: flex; gap: 2px;">
                                    <template x-for="col in 8">
                                        <div class="seq-preview-cell"
                                            :class="{ 'active': getSeqPreviewCell(row-1, col-1) }"
                                            style="width: 8px; height: 8px; border: 1px solid var(--knob-border); background: var(--background-color);">
                                        </div>
                                    </template>
                                </div>
                            </template>
                        </div>
                    </div>

                    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:1rem;justify-items:center;">
                        <div class="knob-wrapper">
                            <label class="knob-label">WAVE</label>
                            <select x-model="synthSettings.waveform" @change="handleWaveformChange()"
                                class="fx-engine-select">
                                <template x-for="(opt, i) in waveformLabels">
                                    <option :value="i * 14" x-text="opt"></option>
                                </template>
                            </select>
                        </div>

                        <template x-for="synthKnob in ['synthFreq', 'synthLen']">
                            <div class="knob-wrapper">
                                <label class="knob-label" x-text="synthKnob === 'synthFreq' ? 'FREQ' : 'LEN'"></label>
                                <div x-data="knob(knobConfigs[synthKnob])" class="knob" @mousedown="startDrag($event)"
                                    @touchstart="startDrag($event)" x-init="knobData.value = knobs[synthKnob].value"
                                    x-effect="knobData.value = knobs[synthKnob].value">
                                    <div class="knob-indicator indicator-small"
                                        :style="`transform: translateX(-50%) rotate(${midiToAngle(knobData.value)}deg)`">
                                    </div>
                                </div>
                                <div class="value-display">
                                    <span class="knob-value"
                                        x-text="synthKnob === 'synthFreq' ? synthFreqDisplayValue : Math.floor(knobs[synthKnob].value * 100 / 127)"></span>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>

                <button @click="settingsView = null" class="overlay-close-btn">BACK</button>
            </div>
        </div>

        <h2 class="master-title">Master</h2>

        <div class="knob-wrapper">
            <div>
                <input x-model.number="bpm" @change="updateBpm()" @focus="$event.target.select()" class="bpm-input"
                    min="40" max="400">
                <div class="knob-label">BPM</div>
            </div>
        </div>

        <button @click="togglePlay()" class="start-stop-button" :class="{ active: startStopActive }">
            <svg class="play-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M8 5v14l11-7z" />
            </svg>
            <svg class="stop-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 6h12v12H6z" />
            </svg>
        </button>

        <button @click="toggleView('lfo')" class="fx-settings-button"
            :class="{ active: settingsView === 'lfo' }">LFO</button>

        <!-- Master knobs -->
        <template x-for="masterKnob in ['masterAux', 'masterCue', 'masterVolume']">
            <div class="knob-wrapper" :class="{ 'main-knob': masterKnob === 'masterVolume' }">
                <div x-data="knob(knobConfigs[masterKnob])" class="knob" @mousedown="startDrag($event)"
                    @touchstart="startDrag($event)" x-init="knobData.value = knobs[masterKnob].value"
                    x-effect="knobData.value = knobs[masterKnob].value">
                    <div class="knob-indicator indicator-small"
                        :style="`transform: translateX(-50%) rotate(${midiToAngle(knobData.value)}deg)`">
                    </div>
                </div>
                <div class="value-display">
                    <span class="knob-value" x-text="Math.floor(knobs[masterKnob].value * 100 / 127)"></span>
                    <span class="knob-label" x-text="masterKnob.replace('master', '')"></span>
                </div>
            </div>
        </template>
    </div>

    <button class="fullscreen-toggle-btn" @click="toggleFullscreen()" x-show="!isFullscreen" title="Enter fullscreen">
        <span>⛶</span>
    </button>

    <script>
        // Constants
        const CC = {
            VOLUME: 7, AUX: 14, CUE: 15, FX: 82, EQ_HIGH: 85, EQ_MID: 86, EQ_LOW: 87,
            FILTER: 74, START_STOP: 46, BPM: 47, FX_ENGINE: 15, FX_PARAM1: 12,
            FX_PARAM2: 13, FX_RETURN: 7, FX_TRACK_SELECT: 9
        };

        const CHANNELS = { MASTER: 6, FX1: 7, FX2: 8 };

        const seqs = [
            '0000000000000000', '1000000000000000', '1000000010000000', '0010001000000000',
            '0000100000001000', '0000000000001100', '1000001010000000', '1000010010000000',
            '0000100000101000', '0000100000001010', '0000100001001010', '0000000000001110',
            '1000100010001000', '1000001010000010', '1010010010000000', '1010001010000000',
            '1001000010100000', '0010001101001000', '0000100100110010', '1010000010101100',
            '1010101010110100', '1010101010101010', '1111111111111111', 'RND',
            'U1', 'U2', 'U3', 'U4', 'U5', 'U6'
        ];

        // Utility functions
        const midiToAngle = (value) => -150 + (value / 127) * 300;
        const lfoRateToAngle = (value) => -150 + (value / 3000) * 300;
        const lfoAmountToAngle = (value) => -150 + (value / 100) * 300;
        const midiToEqDisplay = (value) => {
            const dbValue = Math.round((value - 64) * (18 / 64));
            return dbValue === 0 ? "0dB" : (dbValue > 0 ? "+" + dbValue : dbValue) + "dB";
        };

        // Alpine.js initialization
        document.addEventListener('alpine:init', () => {
            Alpine.data('knob', (config) => ({
                knobData: { value: 0 },
                dragState: { isDragging: false, startValue: 0, initialY: 0 },
                lastTapTime: 0,

                startDrag(event) {
                    event.preventDefault();

                    if (config.doubleClickReset) {
                        const now = Date.now();
                        if (this.lastTapTime && (now - this.lastTapTime) < 300) {
                            this.setValue(config.doubleClickReset);
                            this.lastTapTime = 0;
                            return;
                        }
                        this.lastTapTime = now;
                    }

                    this.dragState.isDragging = true;
                    this.dragState.startValue = this.knobData.value;
                    this.dragState.initialY = event.type === 'touchstart' ?
                        event.touches[0].clientY : event.clientY;

                    const handleMove = (e) => this.handleMove(e);
                    const handleEnd = () => {
                        ['mousemove', 'touchmove', 'mouseup', 'touchend'].forEach((evt, i) => {
                            document.removeEventListener(evt, i < 2 ? handleMove : handleEnd);
                        });
                        this.dragState.isDragging = false;
                    };

                    ['mousemove', 'touchmove'].forEach(evt => document.addEventListener(evt, handleMove));
                    ['mouseup', 'touchend'].forEach(evt => document.addEventListener(evt, handleEnd));
                },

                handleMove(event) {
                    if (!this.dragState.isDragging) return;

                    const currentY = event.type === 'touchmove' ? event.touches[0].clientY : event.clientY;
                    const deltaY = currentY - this.dragState.initialY;
                    const sensitivity = config.sensitivity || 1.5;
                    const valueDelta = Math.round(-deltaY / sensitivity);

                    const minValue = config.minValue || 0;
                    const maxValue = config.maxValue || 127;
                    const newValue = Math.max(minValue, Math.min(maxValue, this.dragState.startValue + valueDelta));

                    if (this.knobData.value !== newValue) this.setValue(newValue);
                },

                setValue(value) {
                    this.knobData.value = value;
                    if (config.onChange) config.onChange(value);
                }
            }));
        });

        // MIDI Controller module
        const createMidiController = () => {
            let connectionType = null;
            let bluetoothDevice = null;
            let midiCharacteristic = null;
            let midiAccess = null;
            let midiOutput = null;
            let midiInput = null;
            let isSending = false;
            let sendQueue = [];
            let clockListeners = [];
            let lastClockTime = 0;
            let clockCount = 0;
            let isReceivingClock = false;

            const timestampGenerator = () => {
                let localTime = performance.now() & 8191;
                return [((localTime >> 7) | 0x80) & 0xBF, (localTime & 0x7F) | 0x80];
            };

            const midiEncoder = (midiData) => {
                let midiBLEmessage = [timestampGenerator()[0]];
                for (let pos = 0; pos < midiData.length; pos++) {
                    if ((midiData[pos] >>> 7) === 1) midiBLEmessage.push(timestampGenerator()[1]);
                    midiBLEmessage.push(midiData[pos]);
                }
                return midiBLEmessage;
            };

            const processQueue = () => {
                if (isSending || sendQueue.length === 0) return;

                const msg = sendQueue.shift();
                isSending = true;

                const sendNext = () => {
                    isSending = false;
                    if (sendQueue.length > 0) setTimeout(processQueue, 0);
                };

                try {
                    if (connectionType === 'ble' && midiCharacteristic) {
                        const bleMidiData = new Uint8Array(midiEncoder(msg.data));
                        midiCharacteristic.writeValue(bleMidiData)
                            .then(() => { msg.resolve(); sendNext(); })
                            .catch(error => { console.error('BLE send error:', error); msg.reject(error); sendNext(); });
                    } else if (connectionType === 'usb' && midiOutput) {
                        midiOutput.send(msg.data);
                        msg.resolve();
                        sendNext();
                    } else {
                        msg.resolve();
                        sendNext();
                    }
                } catch (error) {
                    console.error('Error in MIDI send:', error);
                    msg.reject(error);
                    sendNext();
                }
            };

            const sendMidiData = (data) => {
                const isRealtime = data.length === 1 && data[0] >= 0xF8;
                return new Promise((resolve, reject) => {
                    const msg = { data, resolve, reject };
                    isRealtime && sendQueue.length > 0 ? sendQueue.unshift(msg) : sendQueue.push(msg);
                    if (!isSending) setTimeout(processQueue, 0);
                });
            };

            const sendCC = (channel, controller, value) => sendMidiData([0xB0 + channel, controller, value]);
            const sendSystemRealTime = (message) => sendMidiData([message]);

            const processMidiMessage = (data) => {
                const message = data[0];
                const now = performance.now();

                if (message === 0xF8) { // Clock
                    clockCount++;
                    if (!isReceivingClock) isReceivingClock = true;

                    if (clockCount % 24 === 0 && lastClockTime > 0) {
                        const bpm = 60000 / (now - lastClockTime);
                        clockListeners.forEach(cb => {
                            try { cb({ type: 'clock', bpm, clockCount, timestamp: now }); }
                            catch (e) { console.error('Error in clock listener:', e); }
                        });
                    }
                    if (clockCount % 24 === 0) lastClockTime = now;
                } else if ([0xFA, 0xFB, 0xFC].includes(message)) {
                    const types = { 0xFA: 'start', 0xFB: 'continue', 0xFC: 'stop' };
                    if (message === 0xFA) clockCount = 0;
                    isReceivingClock = message !== 0xFC;
                    clockListeners.forEach(cb => {
                        try { cb({ type: types[message], timestamp: now }); }
                        catch (e) { console.error('Error in clock listener:', e); }
                    });
                }
            };

            const connectBle = async () => {
                if (!navigator.bluetooth) throw new Error('Web Bluetooth API not supported');

                const MIDI_SERVICE_UUID = '03b80e5a-ede8-4b33-a751-6ce34ec4c700';
                const MIDI_IO_CHARACTERISTIC_UUID = '7772e5db-3868-4112-a1a9-f2669d106bf3';

                // Try to connect to TX-6 first, but allow other MIDI BLE devices
                let requestOptions = {
                    filters: [
                        { services: [MIDI_SERVICE_UUID], namePrefix: 'TX-6' },
                        { services: [MIDI_SERVICE_UUID], name: 'TX-6' }
                    ],
                    optionalServices: [MIDI_SERVICE_UUID]
                };

                try {
                    bluetoothDevice = await navigator.bluetooth.requestDevice(requestOptions);
                } catch (error) {
                    // If TX-6 not found, allow selection of any MIDI BLE device
                    try {
                        requestOptions = {
                            filters: [{ services: [MIDI_SERVICE_UUID] }],
                            optionalServices: [MIDI_SERVICE_UUID]
                        };
                        bluetoothDevice = await navigator.bluetooth.requestDevice(requestOptions);
                    } catch (secondError) {
                        throw new Error('No MIDI BLE devices found or user cancelled selection');
                    }
                }

                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService(MIDI_SERVICE_UUID);
                midiCharacteristic = await service.getCharacteristic(MIDI_IO_CHARACTERISTIC_UUID);
                connectionType = 'ble';

                await midiCharacteristic.startNotifications();
                midiCharacteristic.addEventListener('characteristicvaluechanged', (event) => {
                    const value = event.target.value;
                    const data = new Uint8Array(value.buffer);
                    let midiData = [];
                    for (let i = 1; i < data.length; i++) {
                        if ((data[i] & 0x80) === 0) midiData.push(data[i]);
                    }
                    if (midiData.length > 0) processMidiMessage(midiData);
                });

                return bluetoothDevice;
            };

            const connectUsb = async () => {
                if (!navigator.requestMIDIAccess) throw new Error('Web MIDI API not supported');

                midiAccess = await navigator.requestMIDIAccess({ sysex: true });
                const outputs = Array.from(midiAccess.outputs.values());
                const inputs = Array.from(midiAccess.inputs.values());

                if (outputs.length === 0) throw new Error('No MIDI output devices found');

                // Prefer TX-6 but allow selection from available devices
                let preferredOutput = outputs.find(output =>
                    output.name && output.name.toLowerCase().includes('tx-6')
                );

                if (preferredOutput) {
                    midiOutput = preferredOutput;
                } else if (outputs.length === 1) {
                    // If only one device, use it
                    midiOutput = outputs[0];
                } else {
                    // Multiple devices available, let user choose
                    const deviceNames = outputs.map((output, index) => `${index + 1}. ${output.name || 'Unknown Device'}`);
                    const choice = prompt(`Multiple MIDI devices found. Choose one:\n${deviceNames.join('\n')}\n\nEnter number (1-${outputs.length}):`);
                    
                    const choiceIndex = parseInt(choice) - 1;
                    if (isNaN(choiceIndex) || choiceIndex < 0 || choiceIndex >= outputs.length) {
                        throw new Error('Invalid device selection');
                    }
                    
                    midiOutput = outputs[choiceIndex];
                }

                midiInput = inputs.find(input => input.name?.toLowerCase().includes('tx-6'));
                if (midiInput) {
                    midiInput.onmidimessage = (event) => processMidiMessage(event.data);
                }

                connectionType = 'usb';
                return midiOutput;
            };

            return {
                sendCC, sendSystemRealTime, connectBle, connectUsb,
                addClockListener: (cb) => clockListeners.push(cb),
                removeClockListener: (cb) => clockListeners.splice(clockListeners.indexOf(cb), 1),
                getClockStatus: () => ({ isReceivingClock, clockCount })
            };
        };

        // Main Alpine.js component
        window.tx6Controller = () => ({
            // State
            status: '',
            isConnected: false,
            connecting: false,
            clockStatus: { isReceiving: false, bpm: 0, clockCount: 0, lastUpdate: 0 },
            currentTrack: 0,

            lfoOutputValues: {},
            currentSliderMode: 7,
            currentEqMode: 74,
            bpm: parseInt(localStorage.getItem('tx6-bpm')) || 100,
            startStopActive: false,
            isFullscreen: false,
            settingsView: null,
            currentLfoIndex: 0,
            lfoPhases: Array(10).fill(0),
            lfoStartTime: null,
            lastTapTime: 0,
            trackValues: {},
            midi: null,

            // Consolidated knob configurations - must be a getter to maintain context
            get knobConfigs() {
                return {
                    eq: {
                        knobType: 'eq', minValue: 0, maxValue: 127, sensitivity: 1.5, doubleClickReset: 64,
                        onChange: (v) => { this.handleEqChange(v); this.setKnobValue('eq', v); }
                    },
                    masterVolume: { knobType: 'masterVolume', onChange: (v) => { this.handleKnobChange('masterVolume', v); this.setKnobValue('masterVolume', v); } },
                    masterAux: { knobType: 'masterAux', onChange: (v) => { this.handleKnobChange('masterAux', v); this.setKnobValue('masterAux', v); } },
                    masterCue: { knobType: 'masterCue', onChange: (v) => { this.handleKnobChange('masterCue', v); this.setKnobValue('masterCue', v); } },
                    fxReturn: { knobType: 'fxReturn', onChange: (v) => { this.handleKnobChange('fxReturn', v); this.setKnobValue('fxReturn', v); } },
                    fxParam1: { knobType: 'fxParam1', onChange: (v) => { this.handleKnobChange('fxParam1', v); this.setKnobValue('fxParam1', v); } },
                    fxParam2: { knobType: 'fxParam2', onChange: (v) => { this.handleKnobChange('fxParam2', v); this.setKnobValue('fxParam2', v); } },
                    lfoRate: {
                        knobType: 'lfoRate', minValue: 0, maxValue: 3000, sensitivity: 0.4,
                        onChange: (v) => { this.handleKnobChange('lfoRate', v); this.setKnobValue('lfoRate', v); }
                    },
                    lfoAmount: {
                        knobType: 'lfoAmount', minValue: 0, maxValue: 100, sensitivity: 1.5, doubleClickReset: 50,
                        onChange: (v) => { this.handleKnobChange('lfoAmount', v); this.setKnobValue('lfoAmount', v); }
                    },
                    lfoPhase: { knobType: 'lfoPhase', onChange: (v) => { this.handleKnobChange('lfoPhase', v); this.setKnobValue('lfoPhase', v); } },
                    synthFreq: { knobType: 'synthFreq', onChange: (v) => { this.handleKnobChange('synthFreq', v); this.setKnobValue('synthFreq', v); } },
                    synthLen: { knobType: 'synthLen', onChange: (v) => { this.handleKnobChange('synthLen', v); this.setKnobValue('synthLen', v); } }
                };
            },

            // Knobs state
            knobs: {
                eq: { value: 64 }, masterVolume: { value: 0 }, masterAux: { value: 0 },
                masterCue: { value: 0 }, fxParam1: { value: 0 }, fxParam2: { value: 0 },
                fxReturn: { value: 0 }, lfoRate: { value: 64 }, lfoAmount: { value: 0 },
                lfoPhase: { value: 0 }, synthFreq: { value: 0 }, synthLen: { value: 0 }
            },

            // Global LFOs - simplified initialization
            globalLfos: Array(10).fill(null).map((_, i) => ({
                name: `LFO ${i + 1}`,
                target: 'vol',
                shape: ['sine', 'triangle', 'square', 'saw', 'sine'][i % 5],
                enabled: true,
                rate: 1.0,
                amount: 50,
                phase: 0,
                assignedTrack: 0 //i < 5 ? i : 0
            })),

            // FX state
            fx: {
                fx1Active: false, fx2Active: false, currentChannel: 7,
                channels: {
                    7: { types: ['REV', 'CHO', 'DLY'], engine: 0, values: { param1: 0, param2: 0, return: 0 } },
                    8: { types: ['FLT', 'CRU', 'DST', 'TRM', 'FRZ', 'TPE'], engine: 0, values: { param1: 0, param2: 0, track: 0 } }
                }
            },

            // FX parameter configuration
            paramConfig: {
                'REV': { param1: { values: ['LIGHT', 'SMALL', 'MEDIUM', 'LARGE', 'DRONE'] } },
                'CHO': { param1: { values: ['SUBTLE', 'MEDIUM', 'STRONG'] } },
                'DLY': { param1: { values: ['1/8', '1/4', '1/2', '2/3', '3/4', '1', '3/2', 'WARP', 'MASH'] } },
                'CRU': { param1: { values: ['SHAPE', 'BEND', 'CHIP', 'BIT'] } },
                'DST': { param1: { values: ['PUSH', 'DRIVE', 'BLOW', 'DSTROY'] } },
                'TPE': { param1: { values: ['STOP 1', 'STOP 2', 'PONG'] } }
            },

            // Synth settings
            synthSettings: { seq: '0', waveform: '0' },
            waveformLabels: ['SIN', 'TRI', 'SQR', 'SAW', 'KICK', 'SNARE', 'CLAP', 'HIHAT', 'SAMPLE', 'MIDI'],
            noteNames: Array(128).fill(null).map((_, i) => {
                const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return notes[i % 12] + Math.floor(i / 12);
            }),

            // Helper methods
            toggleView(view) {
                this.settingsView = this.settingsView === view ? null : view;
            },

            getKnobAngle(type, value) {
                if (type === 'lfoRate') return lfoRateToAngle(value);
                if (type === 'lfoAmount') return lfoAmountToAngle(value);
                return midiToAngle(value);
            },

            getKnobDisplayValue(knobId) {
                if (knobId === 'fxReturn') return this.fxTrackDisplayValue;
                if (knobId === 'fxParam1') return this.fxParam1DisplayValue;
                if (knobId === 'fxParam2') return Math.floor(this.knobs.fxParam2.value * 100 / 127);
                return Math.floor(this.knobs[knobId].value * 100 / 127);
            },

            getKnobLabel(knobId) {
                if (knobId === 'fxReturn') return this.fx.currentChannel === 7 ? 'Return' : 'Track';
                if (knobId === 'fxParam2') return 'res';
                return '';
            },

            getLfoKnobDisplay(knobType) {
                const lfo = this.globalLfos[this.currentLfoIndex];
                if (knobType === 'lfoRate') return (lfo.rate / 100).toFixed(2);
                if (knobType === 'lfoAmount') return (this.knobs.lfoAmount.value - 50);
                if (knobType === 'lfoPhase') return Math.floor(this.knobs.lfoPhase.value * 360 / 127);
            },

            getLfoKnobUnit(knobType) {
                if (knobType === 'lfoRate') return 'Hz';
                if (knobType === 'lfoPhase') return '°';
                return '';
            },

            getRateButtonLabel(mult) {
                const labels = { 0.25: '1', 0.5: '½', [1 / 3]: '⅓', 1: '¼', 2: '⅛', 4: '1/16' };
                return labels[mult];
            },

            init() {
                this.midi = createMidiController();
                this.initializeTrackValues();
                this.setupFullscreenListener();
                this.updateLfoKnobs();
                this.lfoStartTime = performance.now() / 1000;
                this.$nextTick(() => this.drawLfoWaveform());

                this.midi.addClockListener(async (clockData) => {
                    this.clockStatus.isReceiving = true;
                    this.clockStatus.lastUpdate = clockData.timestamp;

                    if (clockData.type === 'clock') {
                        const detectedBpm = Math.round(clockData.bpm * 10) / 10;
                        this.bpm = Math.round(detectedBpm);
                        this.clockStatus.bpm = detectedBpm;
                        this.clockStatus.clockCount = clockData.clockCount;
                        
                        // Start timing system if not already active
                        if (!this.startStopActive) {
                            await this.startTimingSystem(false); // false = don't send MIDI clock
                        }
                        this.startStopActive = true;
                    } else if (clockData.type === 'start') {
                        await this.startTimingSystem(false); // false = don't send MIDI clock
                        this.startStopActive = true;
                        this.clockStatus.clockCount = 0;
                    } else if (clockData.type === 'stop') {
                        this.stopTimingSystem();
                        this.startStopActive = false;
                        this.clockStatus.isReceiving = false;
                    } else if (clockData.type === 'continue') {
                        if (!this.startStopActive) {
                            await this.startTimingSystem(false); // false = don't send MIDI clock
                        }
                        this.startStopActive = true;
                    }
                });
            },

            initializeTrackValues() {
                const modes = [7, 14, 15, 74, 82, 85, 86, 87];
                for (let track = 0; track < 7; track++) {
                    for (let mode of modes) {
                        const key = `${track}-${mode}`;
                        this.trackValues[key] = (mode >= 74 && mode <= 87) ? 64 : 0;
                    }
                }
            },

            async connect(type) {
                this.connecting = true;
                const connectionName = type === 'ble' ? 'Bluetooth' : 'USB MIDI';
                this.status = `Connecting to ${connectionName}...`;

                try {
                    await (type === 'ble' ? this.midi.connectBle() : this.midi.connectUsb());
                    this.isConnected = true;
                    this.status = `Connected to TX-6 via ${connectionName}`;
                    setTimeout(() => this.status = '', 2000);
                } catch (error) {
                    this.status = `Connection failed: ${error.message}`;
                    setTimeout(() => this.status = '', 5000);
                } finally {
                    this.connecting = false;
                }
            },

            selectTrack(trackIndex) {
                const currentLfo = this.globalLfos[this.currentLfoIndex];
                currentLfo.rate = this.knobs.lfoRate.value;
                currentLfo.amount = this.knobs.lfoAmount.value;
                currentLfo.phase = this.knobs.lfoPhase.value;

                this.currentTrack = trackIndex;

            },

            selectSliderMode(ccNumber) {
                this.currentSliderMode = Number(ccNumber);
                this.midi.sendCC(this.currentTrack, this.currentSliderMode, this.sliderValue);
            },

            selectEqMode(ccNumber) {
                const oldKey = `eqDisplayValue${this.currentTrack}-${this.currentEqMode}`;
                this.trackValues[oldKey] = this.knobs.eq.value;

                this.currentEqMode = Number(ccNumber);

                const newKey = `${this.currentTrack}-${ccNumber}`;
                const value = this.trackValues[newKey] !== undefined ? this.trackValues[newKey] : 64;

                this.setKnobValue('eq', value);
                this.handleKnobChange('eq', value);
            },

            handleSliderChange(event) {
                const key = `${this.currentTrack}-${this.currentSliderMode}`;
                const value = Number(event.target.value);
                this.trackValues[key] = value;
                this.midi.sendCC(this.currentTrack, this.currentSliderMode, value);

            },

            setKnobValue(knobType, value) {
                if (knobType === 'lfoAmount') {
                    value = Math.max(0, Math.min(100, value));
                }
                this.knobs[knobType].value = value;

                if (['lfoRate', 'lfoAmount', 'lfoPhase'].includes(knobType)) {
                    const prop = knobType.replace('lfo', '').toLowerCase();
                    this.globalLfos[this.currentLfoIndex][prop] = value;
                    this.$nextTick(() => this.drawLfoWaveform());
                }
            },

            handleKnobChange(knobType, value) {
                const ccMap = {
                    masterVolume: [CHANNELS.MASTER, CC.VOLUME],
                    masterAux: [CHANNELS.MASTER, CC.AUX],
                    masterCue: [CHANNELS.MASTER, CC.CUE],
                    synthFreq: [this.currentTrack, 89],
                    synthLen: [this.currentTrack, 90]
                };

                if (ccMap[knobType]) {
                    this.midi.sendCC(...ccMap[knobType], value);
                } else if (knobType === 'fxParam1') {
                    this.midi.sendCC(this.fx.currentChannel, CC.FX_PARAM1, value);
                    this.fx.channels[this.fx.currentChannel].values.param1 = value;
                } else if (knobType === 'fxParam2') {
                    this.midi.sendCC(this.fx.currentChannel, CC.FX_PARAM2, value);
                    this.fx.channels[this.fx.currentChannel].values.param2 = value;
                } else if (knobType === 'fxReturn') {
                    const ccType = this.fx.currentChannel === 7 ? CC.FX_RETURN : CC.FX_TRACK_SELECT;
                    this.midi.sendCC(this.fx.currentChannel, ccType, value);
                    const prop = this.fx.currentChannel === 7 ? 'return' : 'track';
                    this.fx.channels[this.fx.currentChannel].values[prop] = value;
                } else if (['lfoRate', 'lfoAmount', 'lfoPhase'].includes(knobType)) {
                    const prop = knobType.replace('lfo', '').toLowerCase();
                    this.globalLfos[this.currentLfoIndex][prop] = value;
                    this.$nextTick(() => this.drawLfoWaveform());
                }
            },

            async startTimingSystem(sendMidiClock = true) {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                try {
                    if (!this.timingWorklet) {
                        await this.audioContext.audioWorklet.addModule('./timing-processor.js');
                        this.timingWorklet = new AudioWorkletNode(this.audioContext, 'timing-processor');

                        this.timingWorklet.port.onmessage = (event) => {
                            const { type, deltaTime } = event.data;

                            const actions = {
                                midiStart: () => sendMidiClock && this.midi.sendSystemRealTime(0xFA),
                                midiStop: () => sendMidiClock && this.midi.sendSystemRealTime(0xFC),
                                midiClock: () => sendMidiClock && this.midi.sendSystemRealTime(0xF8),
                                lfoUpdate: () => {
                                    for (let i = 0; i < 6; i++) this.runLfo(i, deltaTime);
                                }
                            };

                            if (actions[type]) actions[type]();
                        };
                    }

                    this.timingWorklet.port.postMessage({
                        type: 'start',
                        data: { bpm: this.bpm, currentTime: this.audioContext.currentTime }
                    });

                } catch (error) {
                    console.error('AudioWorklet not supported', error);
                }
            },

            stopTimingSystem() {
                if (this.timingWorklet) {
                    this.timingWorklet.port.postMessage({ type: 'stop' });
                }
            },

            async togglePlay() {
                this.startStopActive = !this.startStopActive;
                if (this.startStopActive) {
                    await this.startTimingSystem(true); // true = send MIDI clock
                } else {
                    this.stopTimingSystem();
                }
            },

            updateBpm() {
                this.bpm = Math.max(40, Math.min(400, this.bpm));
                localStorage.setItem('tx6-bpm', this.bpm.toString());
            },

            handleEqChange(value) {
                this.midi.sendCC(this.currentTrack, this.currentEqMode, value);
                const key = `${this.currentTrack}-${this.currentEqMode}`;
                this.trackValues[key] = value;
            },

            toggleFx(fxNumber) {
                const prop = `fx${fxNumber}Active`;
                this.fx[prop] = !this.fx[prop];
                this.midi.sendCC(fxNumber === 1 ? CHANNELS.FX1 : CHANNELS.FX2, CC.FX, this.fx[prop] ? 127 : 0);
            },

            handleFxEngineChange() {
                const value = parseInt(this.fx.channels[this.fx.currentChannel].engine);
                this.midi.sendCC(this.fx.currentChannel, CC.FX_ENGINE, value);
            },

            handleSeqChange() {
                const value = Math.floor(127 * this.synthSettings.seq / 29);
                this.midi.sendCC(this.currentTrack, 14, value);
            },

            handleWaveformChange() {
                const value = parseInt(this.synthSettings.waveform);
                this.midi.sendCC(this.currentTrack, 3, value);
            },

            getSeqPreviewCell(rowIndex, colIndex) {
                const seqIndex = parseInt(this.synthSettings.seq);
                if (seqIndex < 0 || seqIndex >= seqs.length) return false;

                const pattern = seqs[seqIndex];
                if (typeof pattern === 'string' && pattern.length < 16) return false;

                const stepIndex = rowIndex * 8 + colIndex;
                return pattern[stepIndex] === '1';
            },

            runLfo(trackIdx, dt) {
                const assignedLfos = this.globalLfos.filter(lfo => Number(lfo.assignedTrack) === trackIdx);
                const currentTime = performance.now() / 1000;
                const elapsedTime = currentTime - this.lfoStartTime;

                assignedLfos.forEach((lfo) => {
                    const globalLfoIndex = this.globalLfos.indexOf(lfo);
                    if (lfo.amount === 50) return;

                    const hz = lfo.rate / 100;

                    const absolutePhase = (2 * Math.PI * hz * elapsedTime) % (2 * Math.PI);
                    this.lfoPhases[globalLfoIndex] = absolutePhase;

                    const phaseOffset = (lfo.phase / 127) * 2 * Math.PI;
                    const effectivePhase = (absolutePhase + phaseOffset) % (2 * Math.PI);

                    let shapeVal = 0;
                    const shapes = {
                        sine: () => Math.sin(effectivePhase),
                        triangle: () => 2 * Math.abs((effectivePhase / Math.PI) % 2 - 1) - 1,
                        square: () => Math.sign(Math.sin(effectivePhase)),
                        saw: () => 2 * ((effectivePhase / (2 * Math.PI)) % 1) - 1,
                        revsaw: () => 1 - 2 * ((effectivePhase / (2 * Math.PI)) % 1),
                        noise: () => Math.random() * 2 - 1
                    };

                    shapeVal = shapes[lfo.shape]();
                    const amt = lfo.amount - 50;

                    const targets = {
                        vol: [7, 0],
                        fx1: [91, 0],
                        cmp: [93, 0],
                        flt: [74, 64]
                    };

                    const [cc, defaultBase] = targets[lfo.target];
                    const base = Number(this.trackValues[`${trackIdx}-${cc}`]) || defaultBase;
                    const lfoValue = Math.max(0, Math.min(127, base + amt * shapeVal));

                    const outputKey = `${trackIdx}-${cc}`;
                    this.lfoOutputValues[outputKey] = lfoValue;

                    this.midi.sendCC(trackIdx, cc, Math.round(lfoValue));
                });
            },

            updateLfoKnobs() {
                const currentLfo = this.globalLfos[this.currentLfoIndex];
                this.knobs.lfoRate.value = currentLfo.rate;
                this.knobs.lfoAmount.value = currentLfo.amount;
                this.knobs.lfoPhase.value = currentLfo.phase;

                this.$nextTick(() => this.drawLfoWaveform());
            },

            drawLfoWaveform() {
                const canvas = document.getElementById('lfo-canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerY = height / 2;

                ctx.clearRect(0, 0, width, height);

                const currentLfo = this.globalLfos[this.currentLfoIndex];
                const shape = currentLfo.shape;
                const amount = currentLfo.amount - 50;
                const maxAmplitude = centerY - 20;
                const amplitude = Math.abs(amount) / 50 * maxAmplitude;

                const hz = currentLfo.rate / 100;
                const timeSpan = 60 / this.bpm * 4;
                const cycles = hz * timeSpan;

                ctx.strokeStyle = 'rgba(80, 81, 79, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = 'rgba(80, 81, 79, 0.6)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`${hz.toFixed(2)} Hz`, width - 5, 15);

                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--button-color');
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let x = 0; x < width; x++) {
                    const basePhase = (x / width) * cycles * 2 * Math.PI;
                    const phaseOffset = (currentLfo.phase / 127) * 2 * Math.PI;
                    const phase = basePhase + phaseOffset;

                    let y = 0;
                    const shapes = {
                        sine: () => Math.sin(phase),
                        triangle: () => 2 * Math.abs((phase / Math.PI) % 2 - 1) - 1,
                        square: () => Math.sign(Math.sin(phase)),
                        saw: () => 2 * ((phase / (2 * Math.PI)) % 1) - 1,
                        revsaw: () => 1 - 2 * ((phase / (2 * Math.PI)) % 1),
                        noise: () => Math.random() * 2 - 1
                    };

                    y = shapes[shape]();
                    y = amount >= 0 ? y * amplitude : -y * amplitude;
                    y = centerY - y;

                    x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }

                ctx.stroke();
            },

            setLfoRateFromBpm(multiplier) {
                const quarterNoteDuration = 60 / this.bpm;
                const noteDuration = quarterNoteDuration / multiplier;
                const targetHz = 1 / noteDuration;

                let rateValue = Math.max(0, Math.min(3000, Math.round(targetHz * 100)));

                this.globalLfos[this.currentLfoIndex].rate = rateValue;
                this.knobs.lfoRate.value = rateValue;

                this.$nextTick(() => this.drawLfoWaveform());
            },

            isRateButtonActive(multiplier) {
                const quarterNoteDuration = 60 / this.bpm;
                const noteDuration = quarterNoteDuration / multiplier;
                const targetHz = 1 / noteDuration;
                const expectedRateValue = Math.round(targetHz * 100);

                return this.globalLfos[this.currentLfoIndex].rate === expectedRateValue;
            },

            updateFxDisplay() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                this.setKnobValue('fxParam1', channelData.values.param1);
                this.setKnobValue('fxParam2', channelData.values.param2);

                const returnValue = this.fx.currentChannel === 7 ?
                    channelData.values.return : channelData.values.track;
                this.setKnobValue('fxReturn', returnValue);
            },

            calculateMidiValue(index, totalOptions) {
                return Math.round((index / (totalOptions - 1)) * 127);
            },

            toggleFullscreen() {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
            },

            setupFullscreenListener() {
                document.addEventListener('fullscreenchange', () => {
                    this.isFullscreen = !!document.fullscreenElement;
                });
            },

            midiNoteToFrequency(midiNote) {
                const frequency = 880 * Math.pow(2, (midiNote - 69) / 12);
                return frequency < 100 ? frequency.toFixed(1) : Math.round(frequency);
            },

            // Computed properties
            get eqDisplayValue() {
                if (this.currentEqMode === CC.FILTER) {
                    const filterValues = [10, 11, 13, 15, 18, 22, 24, 29, 33, 39, 47, 53, 63, 71, 85, 101, 114, 136, 163, 184, 219, 247, 295, 353, 397, 475, 534, 639, 763, 859, '1.0k', '1.2k', '1.4k', '1.7k', '1.9k', '2.2k', '2.7k', '3.0k', '3.6k', '4.0k', '4.8k', '5.7k', '6.5k', '7.7k', '8.7k', '10.4k', '12.4k', '14.0k', '16.7k', '20.0k'];
                    const allValues = [...filterValues, '-', ...filterValues];
                    const index = Math.round(this.knobs.eq.value / 127 * 100);
                    return allValues[index];
                } else {
                    return midiToEqDisplay(this.knobs.eq.value);
                }
            },

            get eqIndicatorColor() {
                const colors = {
                    [CC.EQ_MID]: 'var(--accent-color-orange)',
                    [CC.EQ_LOW]: 'var(--accent-color-white)',
                    [CC.FILTER]: 'var(--accent-color)'
                };
                return colors[this.currentEqMode] || 'var(--accent-color-blue)';
            },

            get fxParam1DisplayValue() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                const currentType = channelData.types[Math.floor(this.fx.channels[this.fx.currentChannel].engine / (128 / channelData.types.length))];

                const config = this.paramConfig[currentType];
                if (config?.param1?.values) {
                    const values = config.param1.values;
                    const index = Math.floor(this.knobs.fxParam1.value * values.length / 128);
                    return values[Math.min(index, values.length - 1)];
                }

                return Math.floor(this.knobs.fxParam1.value * 100 / 127);
            },

            get fxTrackDisplayValue() {
                const value = this.knobs.fxReturn.value;

                if (this.fx.currentChannel === 7) {
                    return Math.floor(value * 100 / 127);
                } else {
                    const trackLabels = ['t1', 't2', 't3', 't4', 't5', 't6', 'all'];
                    const segmentSize = 128 / trackLabels.length;
                    const index = Math.min(Math.floor(value / segmentSize), trackLabels.length - 1);
                    return trackLabels[index];
                }
            },

            get fxParam2Visibility() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                const currentType = channelData.types[Math.floor(this.fx.channels[this.fx.currentChannel].engine / (128 / channelData.types.length))];
                return ['FLT'].includes(currentType);
            },

            get sliderValue() {
                const key = `${this.currentTrack}-${this.currentSliderMode}`;
                return this.trackValues[key] || 0;
            },

            get sliderOutputValue() {
                const key = `${this.currentTrack}-${this.currentSliderMode}`;
                
                // Check if there's an LFO assigned to current track that targets current slider mode
                const targets = {
                    vol: 7,
                    fx1: 91, 
                    cmp: 93,
                    flt: 74
                };
                
                const assignedLfos = this.globalLfos.filter(lfo => 
                    Number(lfo.assignedTrack) === Number(this.currentTrack) && 
                    targets[lfo.target] === this.currentSliderMode
                );
                const hasTargetedLfo = assignedLfos.length > 0;
                
                return (this.startStopActive && hasTargetedLfo && this.lfoOutputValues[key] !== undefined) ?
                    this.lfoOutputValues[key] : this.sliderValue;
            },

            get synthFreqDisplayValue() {
                const currentWaveform = this.waveformLabels[Math.floor(this.synthSettings.waveform / 14)];
                const freqValue = this.knobs.synthFreq.value;

                if (['SIN', 'TRI', 'SQR', 'SAW'].includes(currentWaveform)) {
                    const noteIndex = Math.floor(freqValue / 127 * (this.noteNames.length - 1));
                    const noteName = this.noteNames[noteIndex] || 'C0';
                    const frequency = this.midiNoteToFrequency(noteIndex);
                    return `${noteName}\n${frequency}Hz`;
                }

                return Math.floor(freqValue * 100 / 127);
            }
        });

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js');
        }
    </script>
</body>

</html>