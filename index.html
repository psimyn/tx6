<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TX-6 Bluetooth Control</title>
    <meta property="og:title" content="TX-6 Remote">
    <meta property="og:description" content="Control TX-6 with Bluetooth or USB">
    <meta property="og:image" content="https://tx6.psimyn.com/tx6-og-1200.jpg">
    <link rel="stylesheet" href="style.css">
    <meta name="theme-color" content="#e2e2e4">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script defer src="alpine-3.14.9.min.js"></script>
</head>

<body x-data="tx6Controller()" x-init="init()">
    <header>
        <div class="status" x-text="status"></div>
        <div class="connection-buttons">
            <button @click="connectBle()" class="connect-btn" x-show="!isConnected" :disabled="connecting">
                Connect BLE
            </button>
            <button @click="connectUsb()" class="connect-btn" x-show="!isConnected" :disabled="connecting">
                Connect USB
            </button>
                </div>
        <div class="track-selector">
            <template x-for="(track, index) in tracks" :key="index">
                <button class="track-button" :class="{ active: currentTrack === index }" @click="selectTrack(index)"
                    x-text="`T${index + 1}`">
                </button>
            </template>
        </div>
    </header>

    <div class="knob-container">
        <div class="knob-wrapper">
            <select x-model="currentSliderMode" @change="selectSliderMode($event.target.value)" class="mode-select">
                <template x-for="mode in sliderModes" :key="mode.value">
                    <option :value="mode.value" x-text="mode.label"></option>
                </template>
            </select>
            <div class="volume-slider">
                <input type="range" min="0" max="127" x-model="sliderValue" @input="handleSliderChange">
            </div>
            <div class="value-display">
                <span class="knob-value value-large" x-text="Math.floor(sliderValue * 100 / 127)"></span>
            </div>
        </div>

        <div class="knob-wrapper">
            <select x-model="currentEqMode" @change="selectEqMode($event.target.value)" class="mode-select">
                <template x-for="mode in eqModes" :key="mode.value">
                    <option :value="mode.value" x-text="mode.label"></option>
                </template>
            </select>
            <div class="knob" @mousedown="startKnobDrag('eq', $event)" @touchstart="startKnobDrag('eq', $event)">
                <div class="knob-indicator indicator-small"
                    :style="`background: ${eqIndicatorColor}; transform: translateX(-50%) rotate(${knobs.eq.angle}deg)`">
                </div>
            </div>
            <div class="value-display">
                <span class="knob-value" x-text="eqDisplayValue"></span>

            </div>
        </div>

        <div class="fx-buttons">
            <button @click="settingsView = settingsView === 'fx' ? null : 'fx'" class="fx-settings-button white"
                :class="{ active: settingsView === 'fx' }" aria-label="FX settings">
                <span>FX</span>
            </button>
            <button @click="toggleFx(1)" class="fx-button" :class="{ active: fx.fx1Active }">
                <span class="fx-button-inner">FX1</span>
            </button>
            <button @click="toggleFx(2)" class="fx-button orange" :class="{ active: fx.fx2Active }">
                <span class="fx-button-inner">FX2</span>
            </button>
        </div>

        <!-- FX Settings Overlay -->
        <div class="fx-settings-overlay" :class="{ active: settingsView === 'fx' }">

            <div class="fx-channel-tabs">
                <div class="fx-channel-tab" :class="{ active: fx.currentChannel === 7 }"
                    @click="fx.currentChannel = 7; updateFxDisplay()">
                    FX I
                </div>
                <div class="fx-channel-tab" :class="{ active: fx.currentChannel === 8 }"
                    @click="fx.currentChannel = 8; updateFxDisplay()">
                    FX II
                </div>
            </div>

            <div class="fx-settings-knobs">
                <div class="knob-wrapper">
                    <div class="value-display">
                        <select x-model="fx.channels[fx.currentChannel].engine" @change="handleFxEngineChange"
                            class="fx-engine-select">
                            <template x-for="(option, index) in fx.channels[fx.currentChannel].types" :key="index">
                                <option :value="calculateMidiValue(index, fx.channels[fx.currentChannel].types.length)"
                                    x-text="option"></option>
                            </template>
                        </select>
                    </div>
                </div>

                <div class="knob-wrapper">
                    <div class="knob" @mousedown="startKnobDrag('fxParam1', $event)"
                        @touchstart="startKnobDrag('fxParam1', $event)">
                        <div class="knob-indicator indicator-small"
                            :style="`transform: translateX(-50%) rotate(${knobs.fxParam1.angle}deg)`">
                        </div>
                    </div>
                    <div class="value-display">
                        <span class="knob-value" x-text="fxParam1DisplayValue"></span>
                    </div>
                </div>

                <div class="knob-wrapper">
                    <div class="knob" @mousedown="startKnobDrag('fxReturn', $event)"
                        @touchstart="startKnobDrag('fxReturn', $event)">
                        <div class="knob-indicator indicator-small"
                            :style="`transform: translateX(-50%) rotate(${knobs.fxReturn.angle}deg)`">
                        </div>
                    </div>
                    <div class="value-display">
                        <span class="knob-value" x-text="Math.floor(knobs.fxReturn.value * 100 / 127)"></span>
                        <span class="knob-label" x-text="fx.currentChannel === 7 ? 'Return' : 'Track'"></span>
                    </div>
                </div>

                <div class="knob-wrapper" :style="fxParam2Visibility">
                    <div class="knob" @mousedown="startKnobDrag('fxParam2', $event)"
                        @touchstart="startKnobDrag('fxParam2', $event)">
                        <div class="knob-indicator indicator-small"
                            :style="`transform: translateX(-50%) rotate(${knobs.fxParam2.angle}deg)`">
                        </div>
                    </div>
                    <div class="value-display">
                        <span class="knob-value" x-text="Math.floor(knobs.fxParam2.value * 100 / 127)"></span>
                        <span class="knob-label">res</span>
                    </div>
                </div>

            </div>
        </div>

        <!-- LFO Settings Overlay -->
        <div class="fx-settings-overlay lfo-overlay" :class="{ active: settingsView === 'lfo' }" style="z-index: 20;">
            <div style="display:flex;flex-direction:column;align-items:center;gap:1rem;">
                <canvas id="lfo-canvas" width="300" height="100" style="border: 1px solid var(--knob-border); border-radius: 4px;"></canvas>
                <div style="display:flex;gap:2rem;flex-wrap:wrap;justify-content:center;">
                    <div class="knob-wrapper">
                        <div class="value-display">
                            <select id="lfo-target" x-model="lfo[currentTrack].target" class="fx-engine-select">
                                <option value="vol">VOL</option>
                                <option value="fx1">FX1</option>
                                <option value="cmp">CMP</option>
                                <option value="flt">FLT</option>
                            </select>
                        </div>
                    </div>
                    <div class="knob-wrapper">
                        <div class="value-display">
                            <select id="lfo-shape" x-model="lfo[currentTrack].shape" class="fx-engine-select">
                                <option value="sine">Sine</option>
                                <option value="triangle">Triangle</option>
                                <option value="square">Square</option>
                                <option value="saw">Saw</option>
                            </select>
                        </div>
                    </div>
                    <div class="knob-wrapper">
                        <div class="knob" @mousedown="startKnobDrag('lfoRate', $event)"
                            @touchstart="startKnobDrag('lfoRate', $event)">
                            <div class="knob-indicator indicator-small"
                                :style="`transform: translateX(-50%) rotate(${knobs.lfoRate.angle}deg)`"></div>
                        </div>
                        <div class="value-display">
                            <span class="knob-value"
                                x-text="(0.1 + (lfo[currentTrack].rate / 127) * 29.9).toFixed(2)"></span>
                            <span class="knob-label">Hz</span>
                        </div>
                        <div class="rate-buttons">
                            <button @click="setLfoRateFromBpm(0.25)" class="rate-button">1</button>
                            <button @click="setLfoRateFromBpm(0.5)" class="rate-button">1/2</button>
                            <button @click="setLfoRateFromBpm(1)" class="rate-button">1/4</button>
                        </div>
                    </div>
                    <div class="knob-wrapper">
                        <div class="knob" @mousedown="startKnobDrag('lfoAmount', $event)"
                            @touchstart="handleLfoAmountTouchStart($event)" @dblclick="resetLfoAmount()">
                            <div class="knob-indicator indicator-small"
                                :style="`transform: translateX(-50%) rotate(${knobs.lfoAmount.angle}deg)`"></div>
                        </div>
                        <div class="value-display">
                            <span class="knob-value" x-text="(knobs.lfoAmount.value - 50)"></span>
                        </div>
                    </div>
                </div>
                <button @click="settingsView = null" class="overlay-close-btn" aria-label="Close LFO settings">BACK</button>

            </div>
        </div>
        <h2 class="master-title">Master</h2>
            <div class="knob-wrapper">
                <div>
                    <input x-model.number="bpm" @change="updateBpm()" @focus="$event.target.select()"
                        class="bpm-input" min="40" max="400">
                    <div class="knob-label">BPM</div>
                </div>
            </div>

            <button @click="togglePlay()" class="start-stop-button" :class="{ active: startStopActive }">
                <svg class="play-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8 5v14l11-7z" />
                </svg>
                <svg class="stop-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6 6h12v12H6z" />
                </svg>
            </button>

            <button @click="toggleLfoView()" class="fx-settings-button"
                :class="{ active: settingsView === 'lfo' }" aria-label="LFO settings">
                <span>LFO</span>
            </button>

            <div class="knob-wrapper">
                <div class="knob" @mousedown="startKnobDrag('masterAux', $event)"
                    @touchstart="startKnobDrag('masterAux', $event)">
                    <div class="knob-indicator indicator-small"
                        :style="`transform: translateX(-50%) rotate(${knobs.masterAux.angle}deg)`">
                    </div>
                </div>
                <div class="value-display">
                    <span class="knob-value" x-text="Math.floor(knobs.masterAux.value * 100 / 127)"></span>
                    <span class="knob-label">Aux</span>
                </div>
            </div>

            <div class="knob-wrapper">
                <div class="knob" @mousedown="startKnobDrag('masterCue', $event)"
                    @touchstart="startKnobDrag('masterCue', $event)">
                    <div class="knob-indicator indicator-small"
                        :style="`transform: translateX(-50%) rotate(${knobs.masterCue.angle}deg)`">
                    </div>
                </div>
                <div class="value-display">
                    <span class="knob-value" x-text="Math.floor(knobs.masterCue.value * 100 / 127)"></span>
                    <span class="knob-label">Cue</span>
                </div>
            </div>

            <div class="knob-wrapper main-knob">
                <div class="knob" @mousedown="startKnobDrag('masterVolume', $event)"
                    @touchstart="startKnobDrag('masterVolume', $event)">
                    <div class="knob-indicator indicator-small"
                        :style="`transform: translateX(-50%) rotate(${knobs.masterVolume.angle}deg)`">
                    </div>
                </div>
                <div class="value-display">
                    <span class="knob-value value-large"
                        x-text="Math.floor(knobs.masterVolume.value * 100 / 127)"></span>
                    <span class="knob-label">Vol</span>
                </div>
            </div>
        </div>
    </div>

    <button class="fullscreen-toggle-btn" @click="toggleFullscreen()" x-show="!isFullscreen" title="Enter fullscreen"
        aria-label="Enter fullscreen">
        <span>⛶</span>
    </button>

    <script>
        // MIDI constants and utilities
        const MIDI_SERVICE_UUID = '03b80e5a-ede8-4b33-a751-6ce34ec4c700';
        const MIDI_IO_CHARACTERISTIC_UUID = '7772e5db-3868-4112-a1a9-f2669d106bf3';

        const CC = {
            VOLUME: 7,
            AUX: 14,
            CUE: 15,
            FX: 82,
            EQ_HIGH: 85,
            EQ_MID: 86,
            EQ_LOW: 87,
            FILTER: 74,
            START_STOP: 46,
            BPM: 47,
            FX_ENGINE: 15,
            FX_PARAM1: 12,
            FX_PARAM2: 13,
            FX_RETURN: 7,
            FX_TRACK_SELECT: 9
        };

        const CHANNELS = {
            TRACK1: 0, TRACK2: 1, TRACK3: 2, TRACK4: 3, TRACK5: 4, TRACK6: 5,
            MASTER: 6, FX1: 7, FX2: 8
        };

        // Utility functions
        const midiToAngle = (value) => -150 + (value / 127) * 300;
        const lfoAmountToAngle = (value) => -150 + (value / 100) * 300; // 0-100 range, 50 = center (0 degrees)
        const midiToEqDisplay = (value) => {
            const dbValue = Math.round((value - 64) * (18 / 64));
            return dbValue === 0 ? "0dB" : (dbValue > 0 ? "+" + dbValue : dbValue) + "dB";
        };

        // MIDI Controller module
        const createMidiController = () => {
            let connectionType = null;
            let bluetoothDevice = null;
            let midiCharacteristic = null;
            let midiAccess = null;
            let midiOutput = null;
            let isSending = false;
            let sendQueue = [];

            const timestampGenerator = () => {
                let localTime = performance.now() & 8191;
                return [((localTime >> 7) | 0x80) & 0xBF, (localTime & 0x7F) | 0x80];
            };

            const midiEncoder = (midiData) => {
                let midiBLEmessage = [timestampGenerator()[0]];
                for (let pos = 0; pos < midiData.length; pos++) {
                    if ((midiData[pos] >>> 7) === 1) {
                        midiBLEmessage.push(timestampGenerator()[1]);
                    }
                    midiBLEmessage.push(midiData[pos]);
                }
                return midiBLEmessage;
            };

            const processQueue = () => {
                if (isSending || sendQueue.length === 0) return;
                
                const msg = sendQueue.shift();
                isSending = true;
                
                const sendNext = () => {
                    isSending = false;
                    if (sendQueue.length > 0) {
                        // Use setTimeout(0) for minimal delay
                        setTimeout(processQueue, 0);
                    }
                };

                try {
                    if (connectionType === 'ble' && midiCharacteristic) {
                        // For BLE, we need to handle the promise
                        const bleMidiData = new Uint8Array(midiEncoder(msg.data));
                        midiCharacteristic.writeValue(bleMidiData)
                            .then(() => {
                                msg.resolve();
                                sendNext();
                            })
                            .catch(error => {
                                console.error('BLE send error:', error);
                                msg.reject(error);
                                sendNext();
                            });
                    } else if (connectionType === 'usb' && midiOutput) {
                        // For USB, send immediately
                        midiOutput.send(msg.data);
                        msg.resolve();
                        sendNext();
                    } else {
                        // No connection, just resolve
                        msg.resolve();
                        sendNext();
                    }
                } catch (error) {
                    console.error('Error in MIDI send:', error);
                    msg.reject(error);
                    sendNext();
                }
            };

            const sendMidiData = (data) => {
                // For system real-time messages (like clock), prioritize them
                const isRealtime = data.length === 1 && data[0] >= 0xF8;
                
                return new Promise((resolve, reject) => {
                    const msg = { data, resolve, reject };
                    
                    if (isRealtime && sendQueue.length > 0) {
                        // Insert real-time messages at the front of the queue
                        sendQueue.unshift(msg);
                    } else {
                        sendQueue.push(msg);
                    }
                    
                    if (!isSending) {
                        // Use setTimeout(0) for minimal delay
                        setTimeout(processQueue, 0);
                    }
                });
            };

            const sendCC = (channel, controller, value) => {
                return sendMidiData([0xB0 + channel, controller, value]);
            };

            const sendSystemRealTime = (message) => {
                return sendMidiData([message]);
            };

            const connectBle = async () => {
                if (!navigator.bluetooth) {
                    throw new Error('Web Bluetooth API not supported');
                }

                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [MIDI_SERVICE_UUID], name: 'TX-6' }]
                });

                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService(MIDI_SERVICE_UUID);
                midiCharacteristic = await service.getCharacteristic(MIDI_IO_CHARACTERISTIC_UUID);
                connectionType = 'ble';

                await midiCharacteristic.startNotifications();
                return bluetoothDevice;
            };

            const connectUsb = async () => {
                if (!navigator.requestMIDIAccess) {
                    throw new Error('Web MIDI API not supported');
                }

                midiAccess = await navigator.requestMIDIAccess({ sysex: true });
                const outputs = Array.from(midiAccess.outputs.values());

                if (outputs.length === 0) {
                    throw new Error('No MIDI output devices found');
                }

                // Look for TX-6 specifically
                midiOutput = outputs.find(output => 
                    output.name && output.name.toLowerCase().includes('tx-6')
                );

                if (!midiOutput) {
                    throw new Error('TX-6 MIDI device not found');
                }

                connectionType = 'usb';
                return midiOutput;
            };

            const disconnect = () => {
                if (connectionType === 'ble' && bluetoothDevice?.gatt.connected) {
                    bluetoothDevice.gatt.disconnect();
                }
                // Clear any pending messages
                sendQueue = [];
                isSending = false;
                connectionType = null;
                midiCharacteristic = null;
                midiOutput = null;
            };

            return { sendCC, sendSystemRealTime, connectBle, connectUsb, disconnect };
        };

        // Main Alpine.js component
        window.tx6Controller = () => ({
            // Connection state
            status: '',
            isConnected: false,
            connecting: false,

            // Track management
            tracks: Array(6).fill(null).map((_, i) => ({ id: i, name: `T${i + 1}` })),
            currentTrack: 0,

            // Slider state
            sliderValue: 0,
            currentSliderMode: 7, // CC.VOLUME
            sliderModes: [
                { value: 7, label: 'VOL' },
                { value: 92, label: 'AUX' },
                { value: 91, label: 'FX1' },
                { value: 93, label: 'CMP' }
            ],

            // EQ state
            currentEqMode: 74, // Default to Filter
            eqModes: [
                { value: 74, label: 'FLT' },
                { value: 85, label: 'HIGH' },
                { value: 86, label: 'MID' },
                { value: 87, label: 'LOW' }
            ],

            // Knobs state
            knobs: {
                eq: { value: 64, angle: 0 },
                masterVolume: { value: 0, angle: -150 },
                masterAux: { value: 0, angle: -150 },
                masterCue: { value: 0, angle: -150 },

                fxParam1: { value: 0, angle: -150 },
                fxParam2: { value: 0, angle: -150 },
                fxReturn: { value: 0, angle: -150 },
                lfoRate: { value: 64, angle: 0 },
                lfoAmount: { value: 0, angle: -150 }
            },

            toggleLfoView() {
                this.settingsView = this.settingsView === 'lfo' ? null : 'lfo';
                if (this.settingsView === 'lfo') {
                    this.$nextTick(() => this.drawLfoWaveform());
                }
            },

            drawLfoWaveform() {
                const canvas = document.getElementById('lfo-canvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerY = height / 2;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Get current LFO settings
                const currentLfo = this.lfo[this.currentTrack];
                const shape = currentLfo.shape;
                const amount = currentLfo.amount - 50; // Convert to -50 to +50
                const amplitude = Math.abs(amount) / 50 * (centerY - 10); // Scale amplitude
                
                // Calculate frequency - convert rate (0-127) to Hz: 0.1-30Hz
                const hz = 0.1 + (currentLfo.rate / 127) * 29.9;
                
                // Calculate how many cycles to show based on frequency
                // Show 2 seconds worth of waveform
                const timeSpan = 2; // seconds
                const cycles = Math.max(0.5, hz * timeSpan);
                
                // Draw center line
                ctx.strokeStyle = 'rgba(80, 81, 79, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw frequency indicator text
                ctx.fillStyle = 'rgba(80, 81, 79, 0.6)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`${hz.toFixed(2)} Hz`, width - 5, 15);
                
                // Draw waveform
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--button-color');
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = 0; x < width; x++) {
                    // Phase now considers the number of cycles to display
                    const phase = (x / width) * cycles * 2 * Math.PI;
                    let y = 0;
                    
                    switch (shape) {
                        case 'sine':
                            y = Math.sin(phase);
                            break;
                        case 'triangle':
                            y = 2 * Math.abs((phase / Math.PI) % 2 - 1) - 1;
                            break;
                        case 'square':
                            y = Math.sign(Math.sin(phase));
                            break;
                        case 'saw':
                            y = 2 * ((phase / (2 * Math.PI)) % 1) - 1;
                            break;
                    }
                    
                    // Apply amount scaling and invert if negative
                    y = amount >= 0 ? y * amplitude : -y * amplitude;
                    y = centerY - y; // Invert Y coordinate for canvas
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                

            },


            // LFO state: array per track
            lfo: Array(6).fill().map(() => ({
                target: 'vol',
                shape: 'sine',
                enabled: true,
                rate: 10, // 1 Hz default (0-127 mapped to 0.1-10 Hz)
                amount: 50 // 0 default (-50 to +50)
            })),

            // FX state
            fx: {
                fx1Active: false,
                fx2Active: false,
                currentChannel: 7, // CHANNELS.FX1
                channels: {
                    7: { // FX1
                        types: ['REV', 'CHO', 'DLY'],
                        engine: 0,
                        values: { param1: 0, param2: 0, return: 0 }
                    },
                    8: { // FX2
                        types: ['FLT', 'CRU', 'DST', 'TRM', 'FRZ', 'TPE'],
                        engine: 0,
                        values: { param1: 0, param2: 0, track: 0 }
                    }
                }
            },

            // UI state
            bpm: 100,
            midiClockInterval: null,
            startStopActive: false,
            isFullscreen: false,
            activeKnob: null,
            dragState: { startValue: 0, initialY: 0, lastBpmDelta: 0 },
            lastTapTime: 0,
            settingsView: null, // 'fx', 'lfo', or null

            // Track values storage
            trackValues: {},

            // MIDI controller instance
            midi: null,
            midiClockTimer: null,

            // Initialization
            lfoPhases: Array(6).fill(0),

            init() {
                this.midi = createMidiController();
                this.initializeTrackValues();
                this.setupFullscreenListener();
                // Sync LFO knobs to initial track
                this.knobs.lfoRate.value = this.lfo[this.currentTrack].rate;
                this.knobs.lfoRate.angle = midiToAngle(this.lfo[this.currentTrack].rate);
                this.knobs.lfoAmount.value = this.lfo[this.currentTrack].amount;
                this.knobs.lfoAmount.angle = lfoAmountToAngle(this.lfo[this.currentTrack].amount);
                
                // Initial LFO visualization
                this.$nextTick(() => this.drawLfoWaveform());
            },



            runLfo(trackIdx, dt) {
                const lfo = this.lfo[trackIdx];
                if (lfo.amount === 50) return; // Amount is 0, so do nothing
                // Convert rate (0-127) to Hz: 0.1-30Hz
                const hz = 0.1 + (lfo.rate / 127) * 29.9;

                const phaseInc = 2 * Math.PI * hz * dt;
                this.lfoPhases[trackIdx] = (this.lfoPhases[trackIdx] + phaseInc) % (2 * Math.PI);
                let shapeVal = 0;
                switch (lfo.shape) {
                    case 'sine':
                        shapeVal = Math.sin(this.lfoPhases[trackIdx]);
                        break;
                    case 'triangle':
                        shapeVal = 2 * Math.abs((this.lfoPhases[trackIdx] / Math.PI) % 2 - 1) - 1;
                        break;
                    case 'square':
                        shapeVal = Math.sign(Math.sin(this.lfoPhases[trackIdx]));
                        break;
                    case 'saw':
                        shapeVal = 2 * ((this.lfoPhases[trackIdx] / (2 * Math.PI)) % 1) - 1;
                        break;
                }
                // Amount: -50 to +50, but scale it down significantly
                const amt = (lfo.amount - 50) * 0.2; // Scale down by 80% for more reasonable modulation
                // Map to MIDI value (0-127) or -50 to 50 for display
                let lfoValue = 0;
                let cc = 7; // Default VOL
                switch (lfo.target) {
                    case 'vol': {
                        cc = 7;
                        const base = Number(this.trackValues[`${trackIdx}-7`]);
                        lfoValue = Math.max(0, Math.min(127, (isNaN(base) ? 0 : base) + amt * shapeVal));
                        if (this.currentTrack === trackIdx && this.currentSliderMode === 7) {
                            this.sliderValue = lfoValue;
                        }
                        break;
                    }
                    case 'fx1': {
                        cc = 91;
                        const base = Number(this.trackValues[`${trackIdx}-91`]);
                        lfoValue = Math.max(0, Math.min(127, (isNaN(base) ? 0 : base) + amt * shapeVal));
                        if (this.currentTrack === trackIdx && this.currentSliderMode === 91) {
                            this.sliderValue = lfoValue;
                        }
                        break;
                    }
                    case 'cmp': {
                        cc = 93;
                        const base = Number(this.trackValues[`${trackIdx}-93`]);
                        lfoValue = Math.max(0, Math.min(127, (isNaN(base) ? 0 : base) + amt * shapeVal));
                        if (this.currentTrack === trackIdx && this.currentSliderMode === 93) {
                            this.sliderValue = lfoValue;
                        }
                        break;
                    }
                    case 'flt': {
                        cc = 74;
                        const base = Number(this.trackValues[`${trackIdx}-74`]);
                        // Default to 64 for filter
                        lfoValue = Math.max(0, Math.min(127, (isNaN(base) ? 64 : base) + amt * shapeVal));
                        if (this.currentTrack === trackIdx && this.currentSliderMode === 74) {
                            this.sliderValue = lfoValue;
                        }
                        break;
                    }
                }
                
                const roundedValue = Math.round(lfoValue);
                this.midi.sendCC(trackIdx, cc, roundedValue);
                
                // Update the trackValues to maintain state
                const key = `${trackIdx}-${cc}`;
                this.trackValues[key] = roundedValue;
            },

            initializeTrackValues() {
                const modes = [7, 14, 15, 74, 82, 85, 86, 87]; // All CC modes
                for (let track = 0; track < 7; track++) {
                    for (let mode of modes) {
                        const key = `${track}-${mode}`;
                        this.trackValues[key] = (mode >= 74 && mode <= 87) ? 64 : 0;
                    }
                }
            },

            // Connection methods
            async connectBle() {
                this.connecting = true;
                this.status = 'Connecting to Bluetooth...';
                try {
                    await this.midi.connectBle();
                    this.isConnected = true;
                    this.status = 'Connected to TX-6 via Bluetooth';
                    setTimeout(() => this.status = '', 2000);
                } catch (error) {
                    this.status = `Connection failed: ${error.message}`;
                    setTimeout(() => this.status = '', 3000);
                } finally {
                    this.connecting = false;
                }
            },

            async connectUsb() {
                this.connecting = true;
                this.status = 'Connecting to USB MIDI...';
                try {
                    await this.midi.connectUsb();
                    this.isConnected = true;
                    this.status = 'Connected to TX-6 via USB';
                    setTimeout(() => this.status = '', 2000);
                } catch (error) {
                    this.status = `Connection failed: ${error.message}`;
                    setTimeout(() => this.status = '', 3000);
                } finally {
                    this.connecting = false;
                }
            },

            // Track management
            selectTrack(trackIndex) {
                // Save current track's slider value
                const oldKey = `${this.currentTrack}-${this.currentSliderMode}`;
                this.trackValues[oldKey] = this.sliderValue;

                // Save LFO knob values to current track's LFO state
                this.lfo[this.currentTrack].rate = this.knobs.lfoRate.value;
                this.lfo[this.currentTrack].amount = this.knobs.lfoAmount.value;

                this.currentTrack = trackIndex;

                // Load new track's slider value
                const newKey = `${trackIndex}-${this.currentSliderMode}`;
                this.sliderValue = this.trackValues[newKey] || 0;

                // Sync LFO knobs to new track's LFO state
                this.knobs.lfoRate.value = this.lfo[trackIndex].rate;
                this.knobs.lfoRate.angle = midiToAngle(this.lfo[trackIndex].rate);
                this.knobs.lfoAmount.value = this.lfo[trackIndex].amount;
                this.knobs.lfoAmount.angle = lfoAmountToAngle(this.lfo[trackIndex].amount);
                
                // Update LFO visualization
                this.$nextTick(() => this.drawLfoWaveform());
            },

            selectSliderMode(ccNumber) {
                // Save current value
                const oldKey = `${this.currentTrack}-${this.currentSliderMode}`;
                this.trackValues[oldKey] = this.sliderValue;

                this.currentSliderMode = Number(ccNumber);

                // Load value for new mode
                const newKey = `${this.currentTrack}-${ccNumber}`;
                const newValue = this.trackValues[newKey] !== undefined ? this.trackValues[newKey] : 0;
                
                // Update the slider value and send MIDI CC
                this.sliderValue = newValue;
                this.midi.sendCC(this.currentTrack, this.currentSliderMode, newValue);
            },

            selectEqMode(ccNumber) {
                // Save current EQ value
                const oldKey = `eqDisplayValue${this.currentTrack}-${this.currentEqMode}`;
                this.trackValues[oldKey] = this.knobs.eq.value;

                this.currentEqMode = Number(ccNumber);

                // Load EQ value for new mode
                const newKey = `${this.currentTrack}-${ccNumber}`;
                const value = this.trackValues[newKey] !== undefined ? this.trackValues[newKey] : 64;

                // Update the knob's visual state and send MIDI CC
                this.setKnobValue('eq', value);
                this.handleKnobChange('eq', value);
                
                // Force UI update for the knob indicator
                this.knobs.eq.angle = midiToAngle(value);
            },

            handleSliderChange() {
                const key = `${this.currentTrack}-${this.currentSliderMode}`;
                this.trackValues[key] = this.sliderValue;
                this.midi.sendCC(this.currentTrack, this.currentSliderMode, this.sliderValue);
            },

            // Knob handling
            setKnobValue(knobType, value) {
                if (knobType === 'lfoAmount') {
                    // Clamp to 0-100, center is 50
                    value = Math.max(0, Math.min(100, value));
                    this.knobs[knobType].value = value;
                    this.knobs[knobType].angle = lfoAmountToAngle(value);
                } else {
                    this.knobs[knobType].value = value;
                    this.knobs[knobType].angle = midiToAngle(value);
                }
                // Sync LFO knob values to per-track LFO state
                if (knobType === 'lfoRate') {
                    this.lfo[this.currentTrack].rate = value;
                    this.$nextTick(() => this.drawLfoWaveform());
                } else if (knobType === 'lfoAmount') {
                    this.lfo[this.currentTrack].amount = value;
                    this.$nextTick(() => this.drawLfoWaveform());
                }
            },

            startKnobDrag(knobType, event) {
                event.preventDefault();

                // Double tap to reset EQ knob to center
                if (knobType === 'eq') {
                    const now = Date.now();
                    if (this.lastTapTime && (now - this.lastTapTime) < 300) {
                        this.setKnobValue('eq', 64);
                        this.handleEqChange(64);
                        this.lastTapTime = 0;
                        return;
                    }
                    this.lastTapTime = now;
                }

                this.activeKnob = knobType;
                this.dragState.startValue = this.knobs[knobType].value;
                this.dragState.initialY = event.type === 'touchstart' ?
                    event.touches[0].clientY : event.clientY;

                const handleMove = (e) => this.handleKnobMove(e);
                const handleEnd = () => {
                    document.removeEventListener('mousemove', handleMove);
                    document.removeEventListener('touchmove', handleMove);
                    document.removeEventListener('mouseup', handleEnd);
                    document.removeEventListener('touchend', handleEnd);
                    this.activeKnob = null;
                };

                document.addEventListener('mousemove', handleMove);
                document.addEventListener('touchmove', handleMove);
                document.addEventListener('mouseup', handleEnd);
                document.addEventListener('touchend', handleEnd);
            },

            handleKnobMove(event) {
                if (!this.activeKnob) return;

                const currentY = event.type === 'touchmove' ?
                    event.touches[0].clientY : event.clientY;

                const deltaY = currentY - this.dragState.initialY;
                const sensitivity = 1.5;
                const valueDelta = Math.round(-deltaY / sensitivity);
                const newValue = Math.max(0, Math.min(127, this.dragState.startValue + valueDelta));

                if (this.knobs[this.activeKnob].value !== newValue) {
                    this.setKnobValue(this.activeKnob, newValue);
                    this.handleKnobChange(this.activeKnob, newValue);
                }
            },

            handleKnobChange(knobType, value) {
                switch (knobType) {
                    case 'eq':
                        this.handleEqChange(value);
                        break;
                    case 'masterVolume':
                        this.midi.sendCC(CHANNELS.MASTER, CC.VOLUME, value);
                        break;
                    case 'masterAux':
                        this.midi.sendCC(CHANNELS.MASTER, CC.AUX, value);
                        break;
                    case 'masterCue':
                        this.midi.sendCC(CHANNELS.MASTER, CC.CUE, value);
                        break;
                    case 'fxParam1':
                        this.midi.sendCC(this.fx.currentChannel, CC.FX_PARAM1, value);
                        this.fx.channels[this.fx.currentChannel].values.param1 = value;
                        break;
                    case 'fxParam2':
                        this.midi.sendCC(this.fx.currentChannel, CC.FX_PARAM2, value);
                        this.fx.channels[this.fx.currentChannel].values.param2 = value;
                        break;
                    case 'fxReturn':
                        const ccType = this.fx.currentChannel === 7 ? CC.FX_RETURN : CC.FX_TRACK_SELECT;
                        this.midi.sendCC(this.fx.currentChannel, ccType, value);
                        if (this.fx.currentChannel === 7) {
                            this.fx.channels[this.fx.currentChannel].values.return = value;
                        } else {
                            this.fx.channels[this.fx.currentChannel].values.track = value;
                        }
                        break;
                    case 'lfoRate':
                        this.lfo[this.currentTrack].rate = value;
                        break;
                    case 'lfoAmount':
                        this.lfo[this.currentTrack].amount = value;
                        break;
                }
            },

            togglePlay() {
                this.startStopActive = !this.startStopActive;
                if (this.startStopActive) {
                    this.midi.sendSystemRealTime(0xFA); // MIDI Start
                    const interval = 60000 / (this.bpm * 24); // 24 pulses per quarter note
                    const dt = interval / 1000.0;
                    this.midiClockTimer = setInterval(() => {
                        this.midi.sendSystemRealTime(0xF8); // MIDI Clock
                        for (let i = 0; i < 6; i++) {
                            this.runLfo(i, dt);
                        }
                    }, interval);
                } else {
                    this.midi.sendSystemRealTime(0xFC); // MIDI Stop
                    clearInterval(this.midiClockTimer);
                    this.midiClockTimer = null;
                }
            },

            updateBpm() {
                // Ensure BPM is within a reasonable range
                this.bpm = Math.max(40, Math.min(400, this.bpm));
                // If the clock is running, restart it with the new BPM
                if (this.startStopActive) {
                    clearInterval(this.midiClockTimer);
                    const interval = 60000 / (this.bpm * 24);
                    const dt = interval / 1000.0;
                    this.midiClockTimer = setInterval(() => {
                        this.midi.sendSystemRealTime(0xF8); // MIDI Clock
                        for (let i = 0; i < 6; i++) {
                            this.runLfo(i, dt);
                        }
                    }, interval);
                }
            },

            handleEqChange(value) {
                this.midi.sendCC(this.currentTrack, this.currentEqMode, value);
                const key = `${this.currentTrack}-${this.currentEqMode}`;
                this.trackValues[key] = value;
            },

            // FX methods
            toggleFx(fxNumber) {
                if (fxNumber === 1) {
                    this.fx.fx1Active = !this.fx.fx1Active;
                    this.midi.sendCC(CHANNELS.FX1, CC.FX, this.fx.fx1Active ? 127 : 0);
                } else {
                    this.fx.fx2Active = !this.fx.fx2Active;
                    this.midi.sendCC(CHANNELS.FX2, CC.FX, this.fx.fx2Active ? 127 : 0);
                }
            },

            handleLfoAmountTouchStart(event) {
                const now = new Date().getTime();
                const DOUBLE_TAP_DELAY = 300; // ms

                if ((now - this.lastTapTime) < DOUBLE_TAP_DELAY) {
                    event.preventDefault(); // prevent drag from starting
                    this.resetLfoAmount();
                    this.lastTapTime = 0; // reset tap time to prevent triple tap issues
                } else {
                    this.lastTapTime = now;
                    this.startKnobDrag('lfoAmount', event);
                }
            },

            resetLfoAmount() {
                this.lfo[this.currentTrack].amount = 50;
                this.knobs.lfoAmount.value = 50;
                this.knobs.lfoAmount.angle = lfoAmountToAngle(50);
                this.$nextTick(() => this.drawLfoWaveform());
            },

            handleFxEngineChange() {
                const value = parseInt(this.fx.channels[this.fx.currentChannel].engine);
                this.midi.sendCC(this.fx.currentChannel, CC.FX_ENGINE, value);
            },

            setLfoRateFromBpm(multiplier) {
                const quarterNoteDuration = 60 / this.bpm;
                const noteDuration = quarterNoteDuration / multiplier;
                const targetHz = 1 / noteDuration;

                // Convert Hz to our 0-127 scale
                // Formula: hz = 0.1 + (value / 127) * 29.9
                // Reversed: value = ((hz - 0.1) / 29.9) * 127
                let rateValue = ((targetHz - 0.1) / 29.9) * 127;

                // Clamp the value between 0 and 127
                rateValue = Math.max(0, Math.min(127, Math.round(rateValue)));

                this.lfo[this.currentTrack].rate = rateValue;

                // Update the knob visuals
                this.knobs.lfoRate.value = rateValue;
                this.knobs.lfoRate.angle = midiToAngle(rateValue);
                this.$nextTick(() => this.drawLfoWaveform());
            },

            updateFxDisplay() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                this.setKnobValue('fxParam1', channelData.values.param1);
                this.setKnobValue('fxParam2', channelData.values.param2);

                const returnValue = this.fx.currentChannel === 7 ?
                    channelData.values.return : channelData.values.track;
                this.setKnobValue('fxReturn', returnValue);
            },

            calculateMidiValue(index, totalOptions) {
                return Math.round((index / (totalOptions - 1)) * 127);
            },

            toggleFullscreen() {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
            },

            setupFullscreenListener() {
                document.addEventListener('fullscreenchange', () => {
                    this.isFullscreen = !!document.fullscreenElement;
                });
            },

            // Computed properties
            get eqDisplayValue() {
                if (this.currentEqMode === CC.FILTER) {
                    const filterValues = [10, 11, 13, 15, 18, 22, 24, 29, 33, 39, 47, 53, 63, 71, 85, 101, 114, 136, 163, 184, 219, 247, 295, 353, 397, 475, 534, 639, 763, 859, '1.0k', '1.2k', '1.4k', '1.7k', '1.9k', '2.2k', '2.7k', '3.0k', '3.6k', '4.0k', '4.8k', '5.7k', '6.5k', '7.7k', '8.7k', '10.4k', '12.4k', '14.0k', '16.7k', '20.0k'];
                    const kPoint = filterValues.findIndex(a => a === '1.0k');
                    const allValues = [...filterValues, '-', ...filterValues];
                    const index = Math.round(this.knobs.eq.value / 127 * 100);
                    return allValues[index];
                } else {
                    return midiToEqDisplay(this.knobs.eq.value);
                }
            },

            get eqIndicatorColor() {
                switch (this.currentEqMode) {
                    case CC.EQ_MID: return 'var(--accent-color-orange)';
                    case CC.EQ_LOW: return 'var(--accent-color-white)';
                    case CC.FILTER: return 'var(--accent-color)';
                    default: return 'var(--accent-color-blue)';
                }
            },

            get fxParam1DisplayValue() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                const currentType = channelData.types[Math.floor(this.fx.channels[this.fx.currentChannel].engine / (128 / channelData.types.length))];

                // This would contain the parameter configuration logic
                // For now, just return percentage
                return Math.floor(this.knobs.fxParam1.value * 100 / 127);
            },

            get fxParam2Visibility() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                const currentType = channelData.types[Math.floor(this.fx.channels[this.fx.currentChannel].engine / (128 / channelData.types.length))];

                // Hide param2 for certain FX types
                const hideParam2 = ['REV', 'CHO', 'DLY', 'CRU', 'DST', 'TRM', 'FRZ', 'TPE'].includes(currentType);
                return hideParam2 ? 'visibility: hidden' : 'visibility: visible';
            }
        });

        // Service Worker registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js');
        }
    </script>
</body>

</html>