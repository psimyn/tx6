<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TX-6 Bluetooth Control</title>
    <meta property="og:title" content="TX-6 Remote">
    <meta property="og:description" content="Control TX-6 with Bluetooth or USB">
    <meta property="og:image" content="https://tx6.psimyn.com/tx6-og-1200.jpg">
    <link rel="stylesheet" href="style.css">
    <meta name="theme-color" content="#e2e2e4">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="icon-192.png">
    <script defer src="alpine-3.14.9.min.js"></script>
</head>

<body x-data="tx6Controller()" x-init="init()">
    <header>
        <div class="status" x-text="status"></div>
        <div class="connection-buttons">
            <button @click="connectBle()" class="connect-btn" x-show="!isConnected" :disabled="connecting">
                Connect BLE
            </button>
            <button @click="connectUsb()" class="connect-btn" x-show="!isConnected" :disabled="connecting">
                Connect USB
            </button>
        </div>
        <div class="track-selector">
            <template x-for="(track, index) in tracks" :key="index">
                <button class="track-button" :class="{ active: currentTrack === index }" @click="selectTrack(index)"
                    x-text="`T${index + 1}`">
                </button>
            </template>
        </div>
    </header>

    <div class="knob-container">
        <div class="knob-wrapper">
            <select x-model="currentSliderMode" @change="selectSliderMode($event.target.value)" class="mode-select">
                <template x-for="mode in sliderModes" :key="mode.value">
                    <option :value="mode.value" x-text="mode.label"></option>
                </template>
            </select>
            <div class="volume-slider">
                <input type="range" min="0" max="127" x-model="sliderValue" @input="handleSliderChange">
                <input type="range" min="0" max="127" x-model="sliderOutputValue" class="slider-overlay" readonly
                    tabindex="-1">
            </div>
            <div class="value-display">
                <span class="knob-value value-large" x-text="Math.floor(sliderValue * 100 / 127)"></span>
            </div>
        </div>

        <div class="knob-wrapper">
            <select x-model="currentEqMode" @change="selectEqMode($event.target.value)" class="mode-select">
                <template x-for="mode in eqModes" :key="mode.value">
                    <option :value="mode.value" x-text="mode.label"></option>
                </template>
            </select>
            <div class="knob" @mousedown="startKnobDrag('eq', $event)" @touchstart="startKnobDrag('eq', $event)">
                <div class="knob-indicator indicator-small"
                    :style="`background: ${eqIndicatorColor}; transform: translateX(-50%) rotate(${knobs.eq.angle}deg)`">
                </div>
                <div class="knob-indicator indicator-small knob-ghost" x-show="showEqGhost"
                    :style="`background: var(--accent-color-blue); opacity: 0.3; transform: translateX(-50%) rotate(${eqGhostAngle}deg)`">
                </div>
            </div>
            <div class="value-display">
                <span class="knob-value" x-text="eqDisplayValue"></span>

            </div>
        </div>

        <div class="fx-buttons">
            <button @click="settingsView = settingsView === 'fx' ? null : 'fx'" class="fx-settings-button white"
                :class="{ active: settingsView === 'fx' }" aria-label="FX settings">
                <span>FX</span>
            </button>
            <button @click="toggleFx(1)" class="fx-button" :class="{ active: fx.fx1Active }">
                <span class="fx-button-inner">FX1</span>
            </button>
            <button @click="toggleFx(2)" class="fx-button orange" :class="{ active: fx.fx2Active }">
                <span class="fx-button-inner">FX2</span>
            </button>
        </div>

        <div class="fx-settings-overlay" :class="{ active: settingsView === 'fx' }">

            <div class="fx-channel-tabs">
                <div class="fx-channel-tab" :class="{ active: fx.currentChannel === 7 }"
                    @click="fx.currentChannel = 7; updateFxDisplay()">
                    FX I
                </div>
                <div class="fx-channel-tab" :class="{ active: fx.currentChannel === 8 }"
                    @click="fx.currentChannel = 8; updateFxDisplay()">
                    FX II
                </div>
            </div>

            <div class="fx-settings-knobs">
                <div class="knob-wrapper">
                    <div class="value-display">
                        <select x-model="fx.channels[fx.currentChannel].engine" @change="handleFxEngineChange"
                            class="fx-engine-select">
                            <template x-for="(option, index) in fx.channels[fx.currentChannel].types" :key="index">
                                <option :value="calculateMidiValue(index, fx.channels[fx.currentChannel].types.length)"
                                    x-text="option"></option>
                            </template>
                        </select>
                    </div>
                </div>

                <div class="knob-wrapper">
                    <div class="knob" @mousedown="startKnobDrag('fxParam1', $event)"
                        @touchstart="startKnobDrag('fxParam1', $event)">
                        <div class="knob-indicator indicator-small"
                            :style="`transform: translateX(-50%) rotate(${knobs.fxParam1.angle}deg)`">
                        </div>
                    </div>
                    <div class="value-display">
                        <span class="knob-value" x-text="fxParam1DisplayValue"></span>
                    </div>
                </div>

                <div class="knob-wrapper">
                    <div class="knob" @mousedown="startKnobDrag('fxReturn', $event)"
                        @touchstart="startKnobDrag('fxReturn', $event)">
                        <div class="knob-indicator indicator-small"
                            :style="`transform: translateX(-50%) rotate(${knobs.fxReturn.angle}deg)`">
                        </div>
                    </div>
                    <div class="value-display">
                        <span class="knob-value" x-text="Math.floor(knobs.fxReturn.value * 100 / 127)"></span>
                        <span class="knob-label" x-text="fx.currentChannel === 7 ? 'Return' : 'Track'"></span>
                    </div>
                </div>

                <div class="knob-wrapper" :style="fxParam2Visibility">
                    <div class="knob" @mousedown="startKnobDrag('fxParam2', $event)"
                        @touchstart="startKnobDrag('fxParam2', $event)">
                        <div class="knob-indicator indicator-small"
                            :style="`transform: translateX(-50%) rotate(${knobs.fxParam2.angle}deg)`">
                        </div>
                    </div>
                    <div class="value-display">
                        <span class="knob-value" x-text="Math.floor(knobs.fxParam2.value * 100 / 127)"></span>
                        <span class="knob-label">res</span>
                    </div>
                </div>

            </div>
        </div>

        <div class="fx-settings-overlay lfo-overlay" :class="{ active: settingsView === 'lfo' }" style="z-index: 20;">
            <div style="position:relative;display:flex;flex-direction:column;align-items:flex-start;gap:1rem;">
                <div class="knob-wrapper">
                    <div class="value-display">
                        <select id="lfo-target" x-model="globalLfos[currentLfoIndex].target"
                            @change="handleLfoTargetChange($event.target.value)"
                            class="fx-engine-select">
                            <option value="vol">VOL</option>
                            <option value="fx1">FX1</option>
                            <option value="cmp">CMP</option>
                            <option value="flt">FLT</option>
                        </select>
                    </div>
                </div>
                <!-- Canvas with shape selector on the left -->
                <div style="display:flex;align-items:center;gap:1rem;position:relative;">
                    <select id="lfo-shape" x-model="globalLfos[currentLfoIndex].shape" class="fx-engine-select"
                        style="writing-mode:horizontal-tb;">
                        <option value="sine">Sine</option>
                        <option value="triangle">Triangle</option>
                        <option value="square">Square</option>
                        <option value="saw">Saw</option>
                    </select>

                    <canvas id="lfo-canvas" width="300" height="100"
                        style="border: 1px solid var(--knob-border); border-radius: 4px;"></canvas>
                </div>
                <div style="display:flex;gap:2rem;flex-wrap:wrap;justify-content:center;">
                    <div class="knob-wrapper">
                        <label class="knob-label">RATE</label>
                        <div class="knob" @mousedown="startKnobDrag('lfoRate', $event)"
                            @touchstart="startKnobDrag('lfoRate', $event)">
                            <div class="knob-indicator indicator-small"
                                :style="`transform: translateX(-50%) rotate(${knobs.lfoRate.angle}deg)`"></div>
                        </div>
                        <div class="value-display">
                            <span class="knob-value"
                                x-text="(0.1 + (globalLfos[currentLfoIndex].rate / 127) * 29.9).toFixed(2)"></span>
                            <span class="knob-label">Hz</span>
                        </div>
                        <div class="rate-buttons">
                            <button @click="setLfoRateFromBpm(0.25)" class="rate-button" :class="{ 'active': isRateButtonActive(0.25) }">1</button>
                            <button @click="setLfoRateFromBpm(0.5)" class="rate-button" :class="{ 'active': isRateButtonActive(0.5) }">½</button>
                            <button @click="setLfoRateFromBpm(1)" class="rate-button" :class="{ 'active': isRateButtonActive(1) }">¼</button>
                            <button @click="setLfoRateFromBpm(2)" class="rate-button" :class="{ 'active': isRateButtonActive(2) }">⅛</button>
                        </div>
                    </div>
                    <div class="knob-wrapper">
                        <label class="knob-label">SIZE</label>
                        <div class="knob" @mousedown="startKnobDrag('lfoAmount', $event)"
                            @touchstart="handleLfoAmountTouchStart($event)" @dblclick="resetLfoAmount()">
                            <div class="knob-indicator indicator-small"
                                :style="`transform: translateX(-50%) rotate(${knobs.lfoAmount.angle}deg)`"></div>
                        </div>
                        <div class="value-display">
                            <span class="knob-value" x-text="(knobs.lfoAmount.value - 50)"></span>
                        </div>
                    </div>
                    <div class="knob-wrapper">
                        <label class="knob-label">PHASE</label>
                        <div class="knob" @mousedown="startKnobDrag('lfoPhase', $event)"
                            @touchstart="startKnobDrag('lfoPhase', $event)">
                            <div class="knob-indicator indicator-small"
                                :style="`transform: translateX(-50%) rotate(${knobs.lfoPhase.angle}deg)`"></div>
                        </div>
                        <div class="value-display">
                            <span class="knob-value" x-text="Math.floor(knobs.lfoPhase.value * 360 / 127)"></span>°
                        </div>
                    </div>
                </div>

                <select x-model="currentLfoIndex" @change="updateLfoKnobs()" class="fx-engine-select"
                    style="min-width:80px;">
                    <template x-for="(lfo, index) in globalLfos" :key="index">
                        <option :value="index" x-text="lfo.name"></option>
                    </template>
                </select>

                <button @click="settingsView = null" class="overlay-close-btn"
                    aria-label="Close LFO settings">BACK</button>

            </div>
        </div>
        <h2 class="master-title">Master</h2>
        <div class="knob-wrapper">
            <div>
                <input x-model.number="bpm" @change="updateBpm()" @focus="$event.target.select()" class="bpm-input"
                    min="40" max="400">
                <div class="knob-label">BPM</div>
            </div>
        </div>

        <button @click="togglePlay()" class="start-stop-button" :class="{ active: startStopActive }">
            <svg class="play-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M8 5v14l11-7z" />
            </svg>
            <svg class="stop-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M6 6h12v12H6z" />
            </svg>
        </button>

        <button @click="toggleLfoView()" class="fx-settings-button" :class="{ active: settingsView === 'lfo' }"
            aria-label="LFO settings">
            <span>LFO</span>
        </button>

        <div class="knob-wrapper">
            <div class="knob" @mousedown="startKnobDrag('masterAux', $event)"
                @touchstart="startKnobDrag('masterAux', $event)">
                <div class="knob-indicator indicator-small"
                    :style="`transform: translateX(-50%) rotate(${knobs.masterAux.angle}deg)`">
                </div>
            </div>
            <div class="value-display">
                <span class="knob-value" x-text="Math.floor(knobs.masterAux.value * 100 / 127)"></span>
                <span class="knob-label">Aux</span>
            </div>
        </div>

        <div class="knob-wrapper">
            <div class="knob" @mousedown="startKnobDrag('masterCue', $event)"
                @touchstart="startKnobDrag('masterCue', $event)">
                <div class="knob-indicator indicator-small"
                    :style="`transform: translateX(-50%) rotate(${knobs.masterCue.angle}deg)`">
                </div>
            </div>
            <div class="value-display">
                <span class="knob-value" x-text="Math.floor(knobs.masterCue.value * 100 / 127)"></span>
                <span class="knob-label">Cue</span>
            </div>
        </div>

        <div class="knob-wrapper main-knob">
            <div class="knob" @mousedown="startKnobDrag('masterVolume', $event)"
                @touchstart="startKnobDrag('masterVolume', $event)">
                <div class="knob-indicator indicator-small"
                    :style="`transform: translateX(-50%) rotate(${knobs.masterVolume.angle}deg)`">
                </div>
            </div>
            <div class="value-display">
                <span class="knob-value value-large" x-text="Math.floor(knobs.masterVolume.value * 100 / 127)"></span>
                <span class="knob-label">Vol</span>
            </div>
        </div>
    </div>
    </div>

    <button class="fullscreen-toggle-btn" @click="toggleFullscreen()" x-show="!isFullscreen" title="Enter fullscreen"
        aria-label="Enter fullscreen">
        <span>⛶</span>
    </button>

    <script>
        // MIDI constants and utilities
        const MIDI_SERVICE_UUID = '03b80e5a-ede8-4b33-a751-6ce34ec4c700';
        const MIDI_IO_CHARACTERISTIC_UUID = '7772e5db-3868-4112-a1a9-f2669d106bf3';

        const CC = {
            VOLUME: 7,
            AUX: 14,
            CUE: 15,
            FX: 82,
            EQ_HIGH: 85,
            EQ_MID: 86,
            EQ_LOW: 87,
            FILTER: 74,
            START_STOP: 46,
            BPM: 47,
            FX_ENGINE: 15,
            FX_PARAM1: 12,
            FX_PARAM2: 13,
            FX_RETURN: 7,
            FX_TRACK_SELECT: 9
        };

        const CHANNELS = {
            TRACK1: 0, TRACK2: 1, TRACK3: 2, TRACK4: 3, TRACK5: 4, TRACK6: 5,
            MASTER: 6, FX1: 7, FX2: 8
        };

        // Utility functions
        const midiToAngle = (value) => -150 + (value / 127) * 300;
        const lfoAmountToAngle = (value) => -150 + (value / 100) * 300; // 0-100 range, 50 = center (0 degrees)
        const midiToEqDisplay = (value) => {
            const dbValue = Math.round((value - 64) * (18 / 64));
            return dbValue === 0 ? "0dB" : (dbValue > 0 ? "+" + dbValue : dbValue) + "dB";
        };

        // MIDI Controller module
        const createMidiController = () => {
            let connectionType = null;
            let bluetoothDevice = null;
            let midiCharacteristic = null;
            let midiAccess = null;
            let midiOutput = null;
            let isSending = false;
            let sendQueue = [];

            const timestampGenerator = () => {
                let localTime = performance.now() & 8191;
                return [((localTime >> 7) | 0x80) & 0xBF, (localTime & 0x7F) | 0x80];
            };

            const midiEncoder = (midiData) => {
                let midiBLEmessage = [timestampGenerator()[0]];
                for (let pos = 0; pos < midiData.length; pos++) {
                    if ((midiData[pos] >>> 7) === 1) {
                        midiBLEmessage.push(timestampGenerator()[1]);
                    }
                    midiBLEmessage.push(midiData[pos]);
                }
                return midiBLEmessage;
            };

            const processQueue = () => {
                if (isSending || sendQueue.length === 0) return;

                const msg = sendQueue.shift();
                isSending = true;

                const sendNext = () => {
                    isSending = false;
                    if (sendQueue.length > 0) {
                        // Use setTimeout(0) for minimal delay
                        setTimeout(processQueue, 0);
                    }
                };

                try {
                    if (connectionType === 'ble' && midiCharacteristic) {
                        // For BLE, we need to handle the promise
                        const bleMidiData = new Uint8Array(midiEncoder(msg.data));
                        midiCharacteristic.writeValue(bleMidiData)
                            .then(() => {
                                msg.resolve();
                                sendNext();
                            })
                            .catch(error => {
                                console.error('BLE send error:', error);
                                msg.reject(error);
                                sendNext();
                            });
                    } else if (connectionType === 'usb' && midiOutput) {
                        // For USB, send immediately
                        midiOutput.send(msg.data);
                        msg.resolve();
                        sendNext();
                    } else {
                        // No connection, just resolve
                        msg.resolve();
                        sendNext();
                    }
                } catch (error) {
                    console.error('Error in MIDI send:', error);
                    msg.reject(error);
                    sendNext();
                }
            };

            const sendMidiData = (data) => {
                // For system real-time messages (like clock), prioritize them
                const isRealtime = data.length === 1 && data[0] >= 0xF8;

                return new Promise((resolve, reject) => {
                    const msg = { data, resolve, reject };

                    if (isRealtime && sendQueue.length > 0) {
                        // Insert real-time messages at the front of the queue
                        sendQueue.unshift(msg);
                    } else {
                        sendQueue.push(msg);
                    }

                    if (!isSending) {
                        // Use setTimeout(0) for minimal delay
                        setTimeout(processQueue, 0);
                    }
                });
            };

            const sendCC = (channel, controller, value) => {
                return sendMidiData([0xB0 + channel, controller, value]);
            };

            const sendSystemRealTime = (message) => {
                return sendMidiData([message]);
            };

            const connectBle = async () => {
                if (!navigator.bluetooth) {
                    throw new Error('Web Bluetooth API not supported');
                }

                bluetoothDevice = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [MIDI_SERVICE_UUID], name: 'TX-6' }]
                });

                const server = await bluetoothDevice.gatt.connect();
                const service = await server.getPrimaryService(MIDI_SERVICE_UUID);
                midiCharacteristic = await service.getCharacteristic(MIDI_IO_CHARACTERISTIC_UUID);
                connectionType = 'ble';

                await midiCharacteristic.startNotifications();
                return bluetoothDevice;
            };

            const connectUsb = async () => {
                if (!navigator.requestMIDIAccess) {
                    throw new Error('Web MIDI API not supported');
                }

                midiAccess = await navigator.requestMIDIAccess({ sysex: true });
                const outputs = Array.from(midiAccess.outputs.values());

                if (outputs.length === 0) {
                    throw new Error('No MIDI output devices found');
                }

                // Look for TX-6 specifically
                midiOutput = outputs.find(output =>
                    output.name && output.name.toLowerCase().includes('tx-6')
                );

                if (!midiOutput) {
                    throw new Error('TX-6 MIDI device not found');
                }

                connectionType = 'usb';
                return midiOutput;
            };

            const disconnect = () => {
                if (connectionType === 'ble' && bluetoothDevice?.gatt.connected) {
                    bluetoothDevice.gatt.disconnect();
                }
                // Clear any pending messages
                sendQueue = [];
                isSending = false;
                connectionType = null;
                midiCharacteristic = null;
                midiOutput = null;
            };

            return { sendCC, sendSystemRealTime, connectBle, connectUsb, disconnect };
        };

        // Main Alpine.js component
        window.tx6Controller = () => ({
            // Connection state
            status: '',
            isConnected: false,
            connecting: false,

            // Track management
            tracks: Array(6).fill(null).map((_, i) => ({ id: i, name: `T${i + 1}` })),
            currentTrack: 0,

            // Slider state
            sliderValue: 0,
            lfoOutputValues: {}, // Store LFO-modulated values per track/CC
            currentSliderMode: 7, // CC.VOLUME
            sliderModes: [
                { value: 7, label: 'VOL' },
                { value: 92, label: 'AUX' },
                { value: 91, label: 'FX1' },
                { value: 93, label: 'CMP' }
            ],

            // EQ state
            currentEqMode: 74, // Default to Filter
            eqModes: [
                { value: 74, label: 'FLT' },
                { value: 85, label: 'HIGH' },
                { value: 86, label: 'MID' },
                { value: 87, label: 'LOW' }
            ],

            // Knobs state
            knobs: {
                eq: { value: 64, angle: 0 },
                masterVolume: { value: 0, angle: -150 },
                masterAux: { value: 0, angle: -150 },
                masterCue: { value: 0, angle: -150 },

                fxParam1: { value: 0, angle: -150 },
                fxParam2: { value: 0, angle: -150 },
                fxReturn: { value: 0, angle: -150 },
                lfoRate: { value: 64, angle: 0 },
                lfoAmount: { value: 0, angle: -150 },
                lfoPhase: { value: 0, angle: -150 }
            },

            toggleLfoView() {
                this.settingsView = this.settingsView === 'lfo' ? null : 'lfo';
                if (this.settingsView === 'lfo') {
                    // Switch to the track assigned to the currently selected LFO
                    const currentLfo = this.globalLfos[this.currentLfoIndex];
                    this.switchToTrackForLfo(currentLfo.assignedTrack);
                    this.$nextTick(() => this.drawLfoWaveform());
                }
            },

            drawLfoWaveform() {
                const canvas = document.getElementById('lfo-canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const centerY = height / 2;

                // Clear canvas
                ctx.clearRect(0, 0, width, height);

                // Get current LFO settings
                const currentLfo = this.globalLfos[this.currentLfoIndex];
                const shape = currentLfo.shape;
                const amount = currentLfo.amount - 50; // Convert to -50 to +50
                const amplitude = Math.abs(amount) / 50 * (centerY - 10); // Scale amplitude

                // Calculate frequency - convert rate (0-127) to Hz: 0.1-30Hz
                const hz = 0.1 + (currentLfo.rate / 127) * 29.9;

                // Calculate how many cycles to show based on frequency
                // Show 2 seconds worth of waveform
                const timeSpan = 2; // seconds
                const cycles = Math.max(0.5, hz * timeSpan);

                // Draw center line
                ctx.strokeStyle = 'rgba(80, 81, 79, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw frequency indicator text
                ctx.fillStyle = 'rgba(80, 81, 79, 0.6)';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`${hz.toFixed(2)} Hz`, width - 5, 15);

                // Draw waveform
                ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--button-color');
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let x = 0; x < width; x++) {
                    // Phase now considers the number of cycles to display
                    const basePhase = (x / width) * cycles * 2 * Math.PI;
                    
                    // Apply phase offset from knob (0-127 -> 0-2π radians)
                    const phaseOffset = (currentLfo.phase / 127) * 2 * Math.PI;
                    const phase = basePhase + phaseOffset;
                    let y = 0;

                    switch (shape) {
                        case 'sine':
                            y = Math.sin(phase);
                            break;
                        case 'triangle':
                            y = 2 * Math.abs((phase / Math.PI) % 2 - 1) - 1;
                            break;
                        case 'square':
                            y = Math.sign(Math.sin(phase));
                            break;
                        case 'saw':
                            y = 2 * ((phase / (2 * Math.PI)) % 1) - 1;
                            break;
                    }

                    // Apply amount scaling and invert if negative
                    y = amount >= 0 ? y * amplitude : -y * amplitude;
                    y = centerY - y; // Invert Y coordinate for canvas

                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.stroke();


            },

            globalLfos: [
                { name: 'LFO 1', target: 'vol', shape: 'sine', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 0 },
                { name: 'LFO 2', target: 'vol', shape: 'triangle', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 1 },
                { name: 'LFO 3', target: 'vol', shape: 'square', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 2 },
                { name: 'LFO 4', target: 'vol', shape: 'saw', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 3 },
                { name: 'LFO 5', target: 'vol', shape: 'sine', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 4 },
                { name: 'LFO 6', target: 'vol', shape: 'sine', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 0 },
                { name: 'LFO 7', target: 'vol', shape: 'sine', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 0 },
                { name: 'LFO 8', target: 'vol', shape: 'sine', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 0 },
                { name: 'LFO 9', target: 'vol', shape: 'sine', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 0 },
                { name: 'LFO 10', target: 'vol', shape: 'sine', enabled: true, rate: 10, amount: 50, phase: 0, assignedTrack: 0 },
            ],
            currentLfoIndex: 0, // Currently selected LFO for editing

            // FX state
            fx: {
                fx1Active: false,
                fx2Active: false,
                currentChannel: 7, // CHANNELS.FX1
                channels: {
                    7: { // FX1
                        types: ['REV', 'CHO', 'DLY'],
                        engine: 0,
                        values: { param1: 0, param2: 0, return: 0 }
                    },
                    8: { // FX2
                        types: ['FLT', 'CRU', 'DST', 'TRM', 'FRZ', 'TPE'],
                        engine: 0,
                        values: { param1: 0, param2: 0, track: 0 }
                    }
                }
            },

            // UI state
            bpm: 100,
            midiClockInterval: null,
            startStopActive: false,
            isFullscreen: false,
            activeKnob: null,
            dragState: { startValue: 0, initialY: 0, lastBpmDelta: 0 },
            lastTapTime: 0,
            settingsView: null, // 'fx', 'lfo', or null

            // Track values storage
            trackValues: {},

            // MIDI controller instance
            midi: null,
            midiClockTimer: null,
            lfoTimer: null,

            // Initialization
            lfoPhases: Array(10).fill(0),
            lfoStartTime: null, // Absolute start time for clock sync

            init() {
                this.midi = createMidiController();
                this.initializeTrackValues();
                this.setupFullscreenListener();
                this.updateLfoKnobs();
                this.lfoStartTime = performance.now() / 1000; // Start time in seconds
                this.$nextTick(() => this.drawLfoWaveform());
            },

            runLfo(trackIdx, dt) {
                const assignedLfos = this.globalLfos.filter(lfo => lfo.assignedTrack === trackIdx);
                const currentTime = performance.now() / 1000; // Current time in seconds
                const elapsedTime = currentTime - this.lfoStartTime;

                assignedLfos.forEach((lfo, lfoIndex) => {
                    const globalLfoIndex = this.globalLfos.indexOf(lfo);
                    if (lfo.amount === 50) return; // Amount is 0, so do nothing
                    
                    // Convert rate (0-127) to Hz: 0.1-30Hz
                    const hz = 0.1 + (lfo.rate / 127) * 29.9;

                    // Calculate absolute phase based on elapsed time (eliminates drift)
                    const absolutePhase = (2 * Math.PI * hz * elapsedTime) % (2 * Math.PI);
                    this.lfoPhases[globalLfoIndex] = absolutePhase;
                    
                    // Apply phase offset from knob (0-127 -> 0-2π radians)
                    const phaseOffset = (lfo.phase / 127) * 2 * Math.PI;
                    const effectivePhase = (absolutePhase + phaseOffset) % (2 * Math.PI);
                    
                    let shapeVal = 0;
                    switch (lfo.shape) {
                        case 'sine':
                            shapeVal = Math.sin(effectivePhase);
                            break;
                        case 'triangle':
                            shapeVal = 2 * Math.abs((effectivePhase / Math.PI) % 2 - 1) - 1;
                            break;
                        case 'square':
                            shapeVal = Math.sign(Math.sin(effectivePhase));
                            break;
                        case 'saw':
                            shapeVal = 2 * ((effectivePhase / (2 * Math.PI)) % 1) - 1;
                            break;
                    }
                    // Amount: 0-100 where 50 = no modulation, scale to reasonable MIDI range
                    // Convert to -50 to +50, then scale down for reasonable modulation depth
                    // Scale based on actual knob position: 0-20 range should be subtle, not full range
                    const amountFromCenter = lfo.amount - 50; // -50 to +50
                    const amt = lfo.amount - 50; // ±50 MIDI units max modulation
                    // Map to MIDI value (0-127) or -50 to 50 for display
                    let lfoValue = 0;
                    let cc = 7; // Default VOL
                    switch (lfo.target) {
                        case 'vol': {
                            cc = 7;
                            const base = Number(this.trackValues[`${trackIdx}-7`]);
                            const modulation = amt * shapeVal;
                            lfoValue = Math.max(0, Math.min(127, (isNaN(base) ? 0 : base) + modulation));
                            break;
                        }
                        case 'fx1': {
                            cc = 91;
                            const base = Number(this.trackValues[`${trackIdx}-91`]);
                            lfoValue = Math.max(0, Math.min(127, (isNaN(base) ? 0 : base) + amt * shapeVal));
                            break;
                        }
                        case 'cmp': {
                            cc = 93;
                            const base = Number(this.trackValues[`${trackIdx}-93`]);
                            lfoValue = Math.max(0, Math.min(127, (isNaN(base) ? 0 : base) + amt * shapeVal));
                            break;
                        }
                        case 'flt': {
                            cc = 74;
                            const base = Number(this.trackValues[`${trackIdx}-74`]);
                            // Default to 64 for filter
                            lfoValue = Math.max(0, Math.min(127, (isNaN(base) ? 64 : base) + amt * shapeVal));
                            break;
                        }
                    }

                    // Store the LFO-modulated value
                    const outputKey = `${trackIdx}-${cc}`;
                    this.lfoOutputValues[outputKey] = lfoValue;

                    const roundedValue = Math.round(lfoValue);
                    this.midi.sendCC(trackIdx, cc, roundedValue);

                    // DO NOT update trackValues here - that would overwrite user-set values!
                    // trackValues should ONLY contain user-intended values, never LFO-modulated values
                });
            },

            updateLfoKnobs() {
                // Sync LFO knobs to currently selected global LFO
                const currentLfo = this.globalLfos[this.currentLfoIndex];
                this.knobs.lfoRate.value = currentLfo.rate;
                this.knobs.lfoRate.angle = midiToAngle(currentLfo.rate);
                this.knobs.lfoAmount.value = currentLfo.amount;
                this.knobs.lfoAmount.angle = lfoAmountToAngle(currentLfo.amount);
                this.knobs.lfoPhase.value = currentLfo.phase;
                this.knobs.lfoPhase.angle = midiToAngle(currentLfo.phase);

                // Switch track selector to the track assigned to this LFO (without triggering LFO assignment)
                this.switchToTrackForLfo(currentLfo.assignedTrack);

                // Update LFO visualization
                this.$nextTick(() => this.drawLfoWaveform());
            },

            switchToTrackForLfo(trackIndex) {
                // Switch track for LFO visualization purposes without triggering LFO assignment
                // Save current track's slider value
                const oldKey = `${this.currentTrack}-${this.currentSliderMode}`;
                this.trackValues[oldKey] = this.sliderValue;

                // Save LFO knob values to currently selected global LFO
                const currentLfo = this.globalLfos[this.currentLfoIndex];
                currentLfo.rate = this.knobs.lfoRate.value;
                currentLfo.amount = this.knobs.lfoAmount.value;
                currentLfo.phase = this.knobs.lfoPhase.value;

                this.currentTrack = trackIndex;

                // Update slider to new track's value
                const newKey = `${this.currentTrack}-${this.currentSliderMode}`;
                const userValue = this.trackValues[newKey] || 0;
                this.sliderValue = userValue;

                // Ensure we're showing the user value, not any lingering LFO value
                if (this.lfoOutputValues[newKey] !== undefined && !this.startStopActive) {
                    delete this.lfoOutputValues[newKey];
                }
            },

            initializeTrackValues() {
                const modes = [7, 14, 15, 74, 82, 85, 86, 87]; // All CC modes
                for (let track = 0; track < 7; track++) {
                    for (let mode of modes) {
                        const key = `${track}-${mode}`;
                        this.trackValues[key] = (mode >= 74 && mode <= 87) ? 64 : 0;
                    }
                }
            },

            // Connection methods
            async connectBle() {
                this.connecting = true;
                this.status = 'Connecting to Bluetooth...';
                try {
                    await this.midi.connectBle();
                    this.isConnected = true;
                    this.status = 'Connected to TX-6 via Bluetooth';
                    setTimeout(() => this.status = '', 2000);
                } catch (error) {
                    this.status = `Connection failed: ${error.message}`;
                    setTimeout(() => this.status = '', 3000);
                } finally {
                    this.connecting = false;
                }
            },

            async connectUsb() {
                this.connecting = true;
                this.status = 'Connecting to USB MIDI...';
                try {
                    await this.midi.connectUsb();
                    this.isConnected = true;
                    this.status = 'Connected to TX-6 via USB';
                    setTimeout(() => this.status = '', 2000);
                } catch (error) {
                    this.status = `Connection failed: ${error.message}`;
                    setTimeout(() => this.status = '', 3000);
                } finally {
                    this.connecting = false;
                }
            },

            // Track management
            selectTrack(trackIndex) {
                // If LFO overlay is open, assign current LFO to the selected track
                if (this.settingsView === 'lfo') {
                    this.globalLfos[this.currentLfoIndex].assignedTrack = trackIndex;
                }

                // Save current track's slider value
                const oldKey = `${this.currentTrack}-${this.currentSliderMode}`;
                this.trackValues[oldKey] = this.sliderValue;

                // Save LFO knob values to currently selected global LFO
                const currentLfo = this.globalLfos[this.currentLfoIndex];
                currentLfo.rate = this.knobs.lfoRate.value;
                currentLfo.amount = this.knobs.lfoAmount.value;
                currentLfo.phase = this.knobs.lfoPhase.value;

                this.currentTrack = trackIndex;

                // Update slider to new track's value
                const newKey = `${this.currentTrack}-${this.currentSliderMode}`;
                const userValue = this.trackValues[newKey] || 0;
                this.sliderValue = userValue;

                // Ensure we're showing the user value, not any lingering LFO value
                if (this.lfoOutputValues[newKey] !== undefined && !this.startStopActive) {
                    delete this.lfoOutputValues[newKey];
                }

                // LFO knobs remain synced to the currently selected global LFO
                // No need to change them when switching tracks
            },

            selectSliderMode(ccNumber) {
                // Save current value
                const oldKey = `${this.currentTrack}-${this.currentSliderMode}`;
                this.trackValues[oldKey] = this.sliderValue;

                this.currentSliderMode = Number(ccNumber);

                // Load value for new mode
                const newKey = `${this.currentTrack}-${ccNumber}`;
                const newValue = this.trackValues[newKey] !== undefined ? this.trackValues[newKey] : 0;

                // Update the slider value and send MIDI CC
                this.sliderValue = newValue;
                this.midi.sendCC(this.currentTrack, this.currentSliderMode, newValue);
            },

            selectEqMode(ccNumber) {
                // Save current EQ value
                const oldKey = `eqDisplayValue${this.currentTrack}-${this.currentEqMode}`;
                this.trackValues[oldKey] = this.knobs.eq.value;

                this.currentEqMode = Number(ccNumber);

                // Load EQ value for new mode
                const newKey = `${this.currentTrack}-${ccNumber}`;
                const value = this.trackValues[newKey] !== undefined ? this.trackValues[newKey] : 64;

                // Update the knob's visual state and send MIDI CC
                this.setKnobValue('eq', value);
                this.handleKnobChange('eq', value);

                // Force UI update for the knob indicator
                this.knobs.eq.angle = midiToAngle(value);
            },

            handleSliderChange() {
                const key = `${this.currentTrack}-${this.currentSliderMode}`;
                this.trackValues[key] = this.sliderValue;
                this.midi.sendCC(this.currentTrack, this.currentSliderMode, this.sliderValue);

                // Clear any LFO output value for this parameter to prevent conflicts
                // The LFO will recalculate from the new base value on next tick
                if (this.lfoOutputValues[key] !== undefined) {
                    delete this.lfoOutputValues[key];
                }
            },

            // Knob handling
            setKnobValue(knobType, value) {
                if (knobType === 'lfoAmount') {
                    // Clamp to 0-100, center is 50
                    value = Math.max(0, Math.min(100, value));
                    this.knobs[knobType].value = value;
                    this.knobs[knobType].angle = lfoAmountToAngle(value);
                } else {
                    this.knobs[knobType].value = value;
                    this.knobs[knobType].angle = midiToAngle(value);
                }
                // Sync LFO knob values to currently selected global LFO
                if (knobType === 'lfoRate') {
                    this.globalLfos[this.currentLfoIndex].rate = value;
                    this.$nextTick(() => this.drawLfoWaveform());
                } else if (knobType === 'lfoAmount') {
                    this.globalLfos[this.currentLfoIndex].amount = value;
                    this.$nextTick(() => this.drawLfoWaveform());
                } else if (knobType === 'lfoPhase') {
                    this.globalLfos[this.currentLfoIndex].phase = value;
                    this.$nextTick(() => this.drawLfoWaveform());
                }
            },

            startKnobDrag(knobType, event) {
                event.preventDefault();

                // Double tap to reset EQ knob to center
                if (knobType === 'eq') {
                    const now = Date.now();
                    if (this.lastTapTime && (now - this.lastTapTime) < 300) {
                        this.setKnobValue('eq', 64);
                        this.handleEqChange(64);
                        this.lastTapTime = 0;
                        return;
                    }
                    this.lastTapTime = now;
                }

                this.activeKnob = knobType;
                this.dragState.startValue = this.knobs[knobType].value;
                this.dragState.initialY = event.type === 'touchstart' ?
                    event.touches[0].clientY : event.clientY;

                const handleMove = (e) => this.handleKnobMove(e);
                const handleEnd = () => {
                    document.removeEventListener('mousemove', handleMove);
                    document.removeEventListener('touchmove', handleMove);
                    document.removeEventListener('mouseup', handleEnd);
                    document.removeEventListener('touchend', handleEnd);
                    this.activeKnob = null;
                };

                document.addEventListener('mousemove', handleMove);
                document.addEventListener('touchmove', handleMove);
                document.addEventListener('mouseup', handleEnd);
                document.addEventListener('touchend', handleEnd);
            },

            handleKnobMove(event) {
                if (!this.activeKnob) return;

                const currentY = event.type === 'touchmove' ?
                    event.touches[0].clientY : event.clientY;

                const deltaY = currentY - this.dragState.initialY;
                const sensitivity = 1.5;
                const valueDelta = Math.round(-deltaY / sensitivity);
                const newValue = Math.max(0, Math.min(127, this.dragState.startValue + valueDelta));

                if (this.knobs[this.activeKnob].value !== newValue) {
                    this.setKnobValue(this.activeKnob, newValue);
                    this.handleKnobChange(this.activeKnob, newValue);
                }
            },

            handleKnobChange(knobType, value) {
                switch (knobType) {
                    case 'eq':
                        this.handleEqChange(value);
                        break;
                    case 'masterVolume':
                        this.midi.sendCC(CHANNELS.MASTER, CC.VOLUME, value);
                        break;
                    case 'masterAux':
                        this.midi.sendCC(CHANNELS.MASTER, CC.AUX, value);
                        break;
                    case 'masterCue':
                        this.midi.sendCC(CHANNELS.MASTER, CC.CUE, value);
                        break;
                    case 'fxParam1':
                        this.midi.sendCC(this.fx.currentChannel, CC.FX_PARAM1, value);
                        this.fx.channels[this.fx.currentChannel].values.param1 = value;
                        break;
                    case 'fxParam2':
                        this.midi.sendCC(this.fx.currentChannel, CC.FX_PARAM2, value);
                        this.fx.channels[this.fx.currentChannel].values.param2 = value;
                        break;
                    case 'fxReturn':
                        const ccType = this.fx.currentChannel === 7 ? CC.FX_RETURN : CC.FX_TRACK_SELECT;
                        this.midi.sendCC(this.fx.currentChannel, ccType, value);
                        if (this.fx.currentChannel === 7) {
                            this.fx.channels[this.fx.currentChannel].values.return = value;
                        } else {
                            this.fx.channels[this.fx.currentChannel].values.track = value;
                        }
                        break;
                    case 'lfoRate':
                        this.globalLfos[this.currentLfoIndex].rate = value;
                        this.$nextTick(() => this.drawLfoWaveform());
                        break;
                    case 'lfoAmount':
                        this.globalLfos[this.currentLfoIndex].amount = value;
                        this.$nextTick(() => this.drawLfoWaveform());
                        break;
                    case 'lfoPhase':
                        this.globalLfos[this.currentLfoIndex].phase = value;
                        this.$nextTick(() => this.drawLfoWaveform());
                        break;
                }
            },

            togglePlay() {
                this.startStopActive = !this.startStopActive;
                if (this.startStopActive) {
                    this.midi.sendSystemRealTime(0xFA); // MIDI Start

                    // MIDI Clock timer (separate from LFO)
                    const midiInterval = 60000 / (this.bpm * 24); // 24 pulses per quarter note
                    this.midiClockTimer = setInterval(() => {
                        this.midi.sendSystemRealTime(0xF8); // MIDI Clock
                    }, midiInterval);

                    // LFO timer at 100Hz (10ms interval)
                    const lfoInterval = 10; // 10ms = 100Hz
                    const lfoDt = lfoInterval / 1000.0; // Convert to seconds
                    this.lfoTimer = setInterval(() => {
                        for (let i = 0; i < 6; i++) {
                            this.runLfo(i, lfoDt);
                        }
                    }, lfoInterval);
                } else {
                    this.midi.sendSystemRealTime(0xFC); // MIDI Stop
                    clearInterval(this.midiClockTimer);
                    this.midiClockTimer = null;
                    clearInterval(this.lfoTimer);
                    this.lfoTimer = null;
                    // Smoothly return to user values instead of instant clear
                    this.smoothReturnToUserValues();
                }
            },

            smoothReturnToUserValues() {
                // Create a smooth transition back to user values over 200ms
                const transitionDuration = 200; // ms
                const steps = 20;
                const stepDuration = transitionDuration / steps;

                // Store initial LFO values for interpolation
                const initialValues = { ...this.lfoOutputValues };

                let currentStep = 0;
                const transitionTimer = setInterval(() => {
                    currentStep++;
                    const progress = currentStep / steps;

                    // Interpolate between LFO values and user values
                    for (const key in initialValues) {
                        const [trackIdx, cc] = key.split('-').map(Number);
                        const lfoValue = initialValues[key];
                        const userValue = this.trackValues[key] || 0;

                        // Linear interpolation
                        const interpolatedValue = lfoValue + (userValue - lfoValue) * progress;
                        this.lfoOutputValues[key] = interpolatedValue;

                        // Send MIDI for the interpolated value
                        this.midi.sendCC(trackIdx, cc, Math.round(interpolatedValue));
                    }

                    if (currentStep >= steps) {
                        clearInterval(transitionTimer);
                        // Clear LFO output values completely after transition
                        this.lfoOutputValues = {};
                    }
                }, stepDuration);
            },

            updateBpm() {
                // Ensure BPM is within a reasonable range
                this.bpm = Math.max(40, Math.min(400, this.bpm));
                // Reset LFO timing to stay synchronized with new BPM
                this.resetLfoTiming();
                // If the clock is running, restart only the MIDI clock with the new BPM
                // LFO timer remains at 100Hz regardless of BPM
                if (this.startStopActive) {
                    clearInterval(this.midiClockTimer);
                    const midiInterval = 60000 / (this.bpm * 24);
                    this.midiClockTimer = setInterval(() => {
                        this.midi.sendSystemRealTime(0xF8); // MIDI Clock
                    }, midiInterval);
                }
            },

            handleEqChange(value) {
                this.midi.sendCC(this.currentTrack, this.currentEqMode, value);
                const key = `${this.currentTrack}-${this.currentEqMode}`;
                this.trackValues[key] = value;
            },

            // FX methods
            toggleFx(fxNumber) {
                if (fxNumber === 1) {
                    this.fx.fx1Active = !this.fx.fx1Active;
                    this.midi.sendCC(CHANNELS.FX1, CC.FX, this.fx.fx1Active ? 127 : 0);
                } else {
                    this.fx.fx2Active = !this.fx.fx2Active;
                    this.midi.sendCC(CHANNELS.FX2, CC.FX, this.fx.fx2Active ? 127 : 0);
                }
            },

            handleLfoAmountTouchStart(event) {
                const now = new Date().getTime();
                const DOUBLE_TAP_DELAY = 300; // ms

                if ((now - this.lastTapTime) < DOUBLE_TAP_DELAY) {
                    event.preventDefault(); // prevent drag from starting
                    this.resetLfoAmount();
                    this.lastTapTime = 0; // reset tap time to prevent triple tap issues
                } else {
                    this.lastTapTime = now;
                    this.startKnobDrag('lfoAmount', event);
                }
            },

            resetLfoAmount() {
                this.globalLfos[this.currentLfoIndex].amount = 50;
                this.knobs.lfoAmount.value = 50;
                this.knobs.lfoAmount.angle = lfoAmountToAngle(50);
                this.$nextTick(() => this.drawLfoWaveform());
            },

            handleFxEngineChange() {
                const value = parseInt(this.fx.channels[this.fx.currentChannel].engine);
                this.midi.sendCC(this.fx.currentChannel, CC.FX_ENGINE, value);
            },

            setLfoRateFromBpm(multiplier) {
                const quarterNoteDuration = 60 / this.bpm;
                const noteDuration = quarterNoteDuration / multiplier;
                const targetHz = 1 / noteDuration;

                // Convert Hz to our 0-127 scale
                // Formula: hz = 0.1 + (value / 127) * 29.9
                // Reversed: value = ((hz - 0.1) / 29.9) * 127
                let rateValue = ((targetHz - 0.1) / 29.9) * 127;

                // Clamp the value between 0 and 127
                rateValue = Math.max(0, Math.min(127, Math.round(rateValue)));

                this.globalLfos[this.currentLfoIndex].rate = rateValue;

                // Update the knob visuals
                this.knobs.lfoRate.value = rateValue;
                this.knobs.lfoRate.angle = midiToAngle(rateValue);
                
                // Reset LFO timing to stay in sync with new rate
                this.resetLfoTiming();
                this.$nextTick(() => this.drawLfoWaveform());
            },

            resetLfoTiming() {
                // Reset the start time to current time to eliminate accumulated drift
                this.lfoStartTime = performance.now() / 1000;
            },

            // todo: model properly
            handleLfoTargetChange(newTarget) {
                // Update the LFO target
                this.globalLfos[this.currentLfoIndex].target = newTarget;
                
                // Force reactivity update to reset ghost indicators
                // This ensures the ghost indicator disappears from the previous target
                this.$nextTick(() => {
                    // Trigger a re-evaluation of computed properties
                    this.$forceUpdate();
                });
            },

            isRateButtonActive(multiplier) {
                // Calculate the expected rate value for this multiplier
                const quarterNoteDuration = 60 / this.bpm;
                const noteDuration = quarterNoteDuration / multiplier;
                const targetHz = 1 / noteDuration;
                const expectedRateValue = Math.round(((targetHz - 0.1) / 29.9) * 127);
                
                // Check if current LFO rate matches (with small tolerance for rounding)
                const currentRate = this.globalLfos[this.currentLfoIndex].rate;
                return Math.abs(currentRate - expectedRateValue) <= 1;
            },

            updateFxDisplay() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                this.setKnobValue('fxParam1', channelData.values.param1);
                this.setKnobValue('fxParam2', channelData.values.param2);

                const returnValue = this.fx.currentChannel === 7 ?
                    channelData.values.return : channelData.values.track;
                this.setKnobValue('fxReturn', returnValue);
            },

            calculateMidiValue(index, totalOptions) {
                return Math.round((index / (totalOptions - 1)) * 127);
            },

            toggleFullscreen() {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
            },

            setupFullscreenListener() {
                document.addEventListener('fullscreenchange', () => {
                    this.isFullscreen = !!document.fullscreenElement;
                });
            },

            // Computed properties
            get eqDisplayValue() {
                if (this.currentEqMode === CC.FILTER) {
                    const filterValues = [10, 11, 13, 15, 18, 22, 24, 29, 33, 39, 47, 53, 63, 71, 85, 101, 114, 136, 163, 184, 219, 247, 295, 353, 397, 475, 534, 639, 763, 859, '1.0k', '1.2k', '1.4k', '1.7k', '1.9k', '2.2k', '2.7k', '3.0k', '3.6k', '4.0k', '4.8k', '5.7k', '6.5k', '7.7k', '8.7k', '10.4k', '12.4k', '14.0k', '16.7k', '20.0k'];
                    const kPoint = filterValues.findIndex(a => a === '1.0k');
                    const allValues = [...filterValues, '-', ...filterValues];
                    const index = Math.round(this.knobs.eq.value / 127 * 100);
                    return allValues[index];
                } else {
                    return midiToEqDisplay(this.knobs.eq.value);
                }
            },

            get eqIndicatorColor() {
                switch (this.currentEqMode) {
                    case CC.EQ_MID: return 'var(--accent-color-orange)';
                    case CC.EQ_LOW: return 'var(--accent-color-white)';
                    case CC.FILTER: return 'var(--accent-color)';
                    default: return 'var(--accent-color-blue)';
                }
            },

            get fxParam1DisplayValue() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                const currentType = channelData.types[Math.floor(this.fx.channels[this.fx.currentChannel].engine / (128 / channelData.types.length))];

                // This would contain the parameter configuration logic
                // For now, just return percentage
                return Math.floor(this.knobs.fxParam1.value * 100 / 127);
            },

            get fxParam2Visibility() {
                const channelData = this.fx.channels[this.fx.currentChannel];
                const currentType = channelData.types[Math.floor(this.fx.channels[this.fx.currentChannel].engine / (128 / channelData.types.length))];

                // Hide param2 for certain FX types
                const hideParam2 = ['REV', 'CHO', 'DLY', 'CRU', 'DST', 'TRM', 'FRZ', 'TPE'].includes(currentType);
                return hideParam2 ? 'visibility: hidden' : 'visibility: visible';
            },

            get sliderOutputValue() {
                const key = `${this.currentTrack}-${this.currentSliderMode}`;
                // Return LFO-modulated value if available and LFO is running, otherwise return user value
                if (this.startStopActive && this.lfoOutputValues[key] !== undefined) {
                    return this.lfoOutputValues[key];
                }
                return this.sliderValue;
            },

            get eqGhostAngle() {
                // Show ghost indicator position for filter LFO modulation
                const filterKey = `${this.currentTrack}-74`; // CC 74 is filter
                if (this.startStopActive && this.lfoOutputValues[filterKey] !== undefined) {
                    return midiToAngle(this.lfoOutputValues[filterKey]);
                }
                return this.knobs.eq.angle; // Fallback to current EQ angle
            },

            get showEqGhost() {
                // Show ghost indicator only when any LFO assigned to current track targets FLT, LFO is running, AND EQ mode is FLT
                const assignedLfos = this.globalLfos.filter(lfo => lfo.assignedTrack === this.currentTrack);
                const hasFilterLfo = assignedLfos.some(lfo => lfo.target === 'flt');
                return hasFilterLfo && this.startStopActive && this.currentEqMode === 74;
            }
        });

        // Service Worker registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.js');
        }
    </script>
</body>

</html>